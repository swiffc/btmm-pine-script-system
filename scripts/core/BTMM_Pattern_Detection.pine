//@version=5

// =============================================================================
// BTMM PATTERN DETECTION - ADVANCED PATTERN RECOGNITION
// =============================================================================
// @description Advanced pattern recognition with multi-timeframe confirmation
// @purpose Detect M/W patterns, OTE zones, and nameable candlestick patterns
// @method Technical analysis pattern recognition with volume confirmation
// @author BTMM Development Team
// @version 2.0 - Performance optimized with cached calculations
// @date 2025-07-02
// =============================================================================

// Note: BTMMFoundation functions imported directly due to local development
// In production, this would use: import username/BTMMFoundation/1 as btmm

// =============================================================================
// BTMM PATTERN DETECTION ENGINE - M&W PATTERNS WITH NAMEABLE PATTERNS
// =============================================================================
// Purpose: Complete M&W pattern detection with institutional nameable patterns
// Method: Advanced pattern recognition with BTMM context analysis
// Author: BTMM Development Team
// Version: 2.0 - Enhanced from Master System
// Date: 2025-07-02
// =============================================================================

indicator("BTMM Pattern Detection", "BTMM Patterns", overlay=true, shorttitle="BTMM Patterns",
         max_boxes_count=100, max_lines_count=200, max_labels_count=200)

// ============================================================================
// 📈 PATTERN DETECTION CONFIGURATION
// ============================================================================

// === PATTERN DETECTION SETTINGS ===
pattern_group = "📈 M&W Pattern Detection"
enable_m_patterns = input.bool(true, "Enable M Patterns (Bearish)", group=pattern_group)
enable_w_patterns = input.bool(true, "Enable W Patterns (Bullish)", group=pattern_group)
min_pattern_bars = input.int(8, "Minimum Pattern Duration (bars)", minval=5, maxval=50, group=pattern_group, tooltip="Minimum bars between pattern points")
pattern_tolerance = input.float(0.002, "Pattern Tolerance (%)", minval=0.001, maxval=0.01, step=0.001, group=pattern_group, tooltip="Symmetry tolerance for pattern validation")
show_pattern_structure = input.bool(true, "Show Pattern Structure Lines", group=pattern_group)

// === NAMEABLE PATTERNS SETTINGS ===
nameable_group = "🌟 Nameable Patterns (Candlestick)"
enable_evening_stars = input.bool(true, "Enable Evening Stars (Bearish)", group=nameable_group)
enable_morning_stars = input.bool(true, "Enable Morning Stars (Bullish)", group=nameable_group)
enable_railroad_tracks = input.bool(true, "Enable Railroad Tracks", group=nameable_group)
enable_cordofwoods = input.bool(true, "Enable Cordofwoods", group=nameable_group)
nameable_strength_filter = input.string("MODERATE", "Minimum Nameable Strength", options=["WEAK", "MODERATE", "STRONG", "ULTIMATE"], group=nameable_group)

// === VISUAL SETTINGS ===
visual_group = "🎨 Visual Configuration"
line_width = input.int(2, "Line Width", minval=1, maxval=5, group=visual_group)
label_size = input.string("normal", "Label Size", options=["tiny", "small", "normal", "large", "huge"], group=visual_group)
show_pattern_labels = input.bool(true, "Show Pattern Labels", group=visual_group)

// ============================================================================
// 🔧 HELPER FUNCTIONS & CALCULATIONS
// ============================================================================

// ATR and volatility calculations
atr_14 = ta.atr(14)
atr_21 = ta.atr(21)
pattern_min_size = atr_14 * 2.0

// Volume calculations
volume_ma = ta.sma(volume, 20)
volume_spike_threshold = volume_ma * 1.5
volume_ratio = volume / volume_ma

// Label size conversion
label_text_size = switch label_size
    "tiny" => size.tiny
    "small" => size.small
    "normal" => size.normal
    "large" => size.large
    "huge" => size.huge
    => size.normal

// ============================================================================
// 📈 M PATTERN DETECTION ENGINE
// ============================================================================

// M Pattern Detection (Bearish)
detect_m_pattern() =>
    var float peak1_price = na
    var float peak2_price = na
    var float valley_price = na
    var int peak1_bar = na
    var int peak2_bar = na
    var int valley_bar = na
    var bool m_pattern_found = false
    var string m_pattern_context = "NONE"

    // Enhanced peak/valley detection
    is_peak = high > high[1] and high > high[-1] and high > ta.highest(high[2], 3) and high > ta.highest(high[-2], 3)
    is_valley = low < low[1] and low < low[-1] and low < ta.lowest(low[2], 3) and low < ta.lowest(low[-2], 3)

    // Reset pattern if timeout
    if not na(peak1_bar) and bar_index - peak1_bar > 100
        peak1_price := na
        peak2_price := na
        valley_price := na
        peak1_bar := na
        peak2_bar := na
        valley_bar := na
        m_pattern_context := "NONE"
        m_pattern_found := false

    // M pattern formation logic
    if is_peak
        if na(peak1_price)
            peak1_price := high
            peak1_bar := bar_index
        else if not na(peak1_price) and na(valley_price)
            peak1_price := high
            peak1_bar := bar_index
        else if not na(valley_price) and na(peak2_price)
            peak2_price := high
            peak2_bar := bar_index

            // BTMM Enhanced validation
            peak_symmetry = math.abs(peak1_price - peak2_price) / peak1_price < pattern_tolerance
            valley_depth = valley_price < math.min(peak1_price, peak2_price) * (1 - pattern_tolerance)
            time_spacing = peak2_bar - peak1_bar >= min_pattern_bars
            size_valid = math.abs(peak1_price - valley_price) > pattern_min_size

            // BTMM Context Analysis (simplified without Asian levels for now)
            if peak1_price > close * 1.01 and peak2_price > close * 1.01
                m_pattern_context := "TYPE_1_RESISTANCE"
            else if math.abs((peak1_price + peak2_price) / 2 - close) < atr_14
                m_pattern_context := "TYPE_2_CURRENT_LEVEL"
            else
                m_pattern_context := "STANDARD"

            if peak_symmetry and valley_depth and time_spacing and size_valid
                m_pattern_found := true

    if is_valley and not na(peak1_price) and na(valley_price)
        valley_price := low
        valley_bar := bar_index

    // Reset after completion
    if m_pattern_found
        m_pattern_found := false  // Reset for next detection

    [peak1_price, peak2_price, valley_price, peak1_bar, peak2_bar, valley_bar, m_pattern_context, is_peak and not na(peak2_price)]

// ============================================================================
// 📈 W PATTERN DETECTION ENGINE
// ============================================================================

// W Pattern Detection (Bullish)
detect_w_pattern() =>
    var float valley1_price = na
    var float valley2_price = na
    var float peak_price = na
    var int valley1_bar = na
    var int valley2_bar = na
    var int peak_bar = na
    var bool w_pattern_found = false
    var string w_pattern_context = "NONE"

    is_peak = high > high[1] and high > high[-1] and high > ta.highest(high[2], 3) and high > ta.highest(high[-2], 3)
    is_valley = low < low[1] and low < low[-1] and low < ta.lowest(low[2], 3) and low < ta.lowest(low[-2], 3)

    // Reset pattern if timeout
    if not na(valley1_bar) and bar_index - valley1_bar > 100
        valley1_price := na
        valley2_price := na
        peak_price := na
        valley1_bar := na
        valley2_bar := na
        peak_bar := na
        w_pattern_context := "NONE"
        w_pattern_found := false

    // W pattern formation logic
    if is_valley
        if na(valley1_price)
            valley1_price := low
            valley1_bar := bar_index
        else if not na(valley1_price) and na(peak_price)
            valley1_price := low
            valley1_bar := bar_index
        else if not na(peak_price) and na(valley2_price)
            valley2_price := low
            valley2_bar := bar_index

            valley_symmetry = math.abs(valley1_price - valley2_price) / valley1_price < pattern_tolerance
            peak_height = peak_price > math.max(valley1_price, valley2_price) * (1 + pattern_tolerance)
            time_spacing = valley2_bar - valley1_bar >= min_pattern_bars
            size_valid = math.abs(peak_price - valley1_price) > pattern_min_size

            if valley1_price < close * 0.99 and valley2_price < close * 0.99
                w_pattern_context := "TYPE_1_SUPPORT"
            else if math.abs((valley1_price + valley2_price) / 2 - close) < atr_14
                w_pattern_context := "TYPE_2_CURRENT_LEVEL"
            else
                w_pattern_context := "STANDARD"

            if valley_symmetry and peak_height and time_spacing and size_valid
                w_pattern_found := true

    if is_peak and not na(valley1_price) and na(peak_price)
        peak_price := high
        peak_bar := bar_index

    if w_pattern_found
        w_pattern_found := false

    [valley1_price, valley2_price, peak_price, valley1_bar, valley2_bar, peak_bar, w_pattern_context, is_valley and not na(valley2_price)]

// Execute pattern detection
[m_peak1, m_peak2, m_valley, m_peak1_bar, m_peak2_bar, m_valley_bar, m_type, m_completed] = detect_m_pattern()
[w_valley1, w_valley2, w_peak, w_valley1_bar, w_valley2_bar, w_peak_bar, w_type, w_completed] = detect_w_pattern()

// ============================================================================
// 🌟 NAMEABLE PATTERNS DETECTION
// ============================================================================

// Evening Star Detection (Bearish)
detect_evening_star() =>
    candle1_bullish = close[2] > open[2] and (close[2] - open[2]) > atr_14 * 0.5
    candle2_small = math.abs(close[1] - open[1]) < atr_14 * 0.3
    candle3_bearish = close < open and (open - close) > atr_14 * 0.5

    star_higher = high[1] > high[2] and high[1] > high
    confirmation_overlap = close < (close[2] + open[2]) / 2

    volume_confirmation = volume > volume_ma * 1.3

    evening_star = candle1_bullish and candle2_small and candle3_bearish and star_higher and confirmation_overlap and volume_confirmation
    evening_star

// Morning Star Detection (Bullish)
detect_morning_star() =>
    candle1_bearish = close[2] < open[2] and (open[2] - close[2]) > atr_14 * 0.5
    candle2_small = math.abs(close[1] - open[1]) < atr_14 * 0.3
    candle3_bullish = close > open and (close - open) > atr_14 * 0.5

    star_lower = low[1] < low[2] and low[1] < low
    confirmation_overlap = close > (close[2] + open[2]) / 2

    volume_confirmation = volume > volume_ma * 1.3

    morning_star = candle1_bearish and candle2_small and candle3_bullish and star_lower and confirmation_overlap and volume_confirmation
    morning_star

// Railroad Tracks Detection
detect_railroad_tracks() =>
    first_candle_size = math.abs(close[1] - open[1])
    second_candle_size = math.abs(close - open)
    size_similarity = math.abs(first_candle_size - second_candle_size) / first_candle_size < 0.2

    bearish_tracks = close[1] > open[1] and close < open and size_similarity
    bullish_tracks = close[1] < open[1] and close > open and size_similarity

    significant_size = first_candle_size > atr_14 * 0.7
    volume_confirmation = volume > volume[1]

    tracks_pattern = (bearish_tracks or bullish_tracks) and significant_size and volume_confirmation
    [tracks_pattern, bearish_tracks, bullish_tracks]

// Cordofwoods Detection
detect_cordofwoods() =>
    var int consecutive_count = 0
    var string direction = "NONE"

    current_body = math.abs(close - open)
    is_small_body = current_body < atr_14 * 0.4
    is_bullish = close > open
    is_bearish = close < open

    if is_small_body
        if direction == "NONE"
            direction := is_bullish ? "BULLISH" : "BEARISH"
            consecutive_count := 1
        else if (direction == "BULLISH" and is_bullish) or (direction == "BEARISH" and is_bearish)
            consecutive_count += 1
        else
            consecutive_count := 1
            direction := is_bullish ? "BULLISH" : "BEARISH"
    else
        consecutive_count := 0
        direction := "NONE"

    bullish_cordofwoods = consecutive_count >= 3 and direction == "BULLISH"
    bearish_cordofwoods = consecutive_count >= 3 and direction == "BEARISH"

    cordofwoods_pattern = bullish_cordofwoods or bearish_cordofwoods
    [cordofwoods_pattern, bullish_cordofwoods, bearish_cordofwoods, consecutive_count]

// Execute nameable pattern detection
evening_star_signal = enable_evening_stars ? detect_evening_star() : false
morning_star_signal = enable_morning_stars ? detect_morning_star() : false
[railroad_signal, bearish_tracks, bullish_tracks] = enable_railroad_tracks ? detect_railroad_tracks() : [false, false, false]
[cordofwoods_signal, bullish_cords, bearish_cords, cord_count] = enable_cordofwoods ? detect_cordofwoods() : [false, false, false, 0]

// ============================================================================
// 🎨 VISUAL ELEMENTS & PATTERN DRAWING
// ============================================================================

// Draw M Pattern
if show_pattern_structure and m_completed and not na(m_peak1) and not na(m_peak2) and not na(m_valley)
    line1 = line.new(m_peak1_bar, m_peak1, m_valley_bar, m_valley, color=color.red, width=line_width + 1, style=line.style_solid)
    line2 = line.new(m_valley_bar, m_valley, m_peak2_bar, m_peak2, color=color.red, width=line_width + 1, style=line.style_solid)

    if show_pattern_labels
        label.new(m_peak2_bar, m_peak2 + atr_14 * 0.5,
                 "🔴 M " + m_type + "\n" + str.tostring(m_peak2, "#.#####"),
                 style=label.style_label_down, color=color.red, textcolor=color.white, size=label_text_size)

// Draw W Pattern
if show_pattern_structure and w_completed and not na(w_valley1) and not na(w_valley2) and not na(w_peak)
    line1 = line.new(w_valley1_bar, w_valley1, w_peak_bar, w_peak, color=color.green, width=line_width + 1, style=line.style_solid)
    line2 = line.new(w_peak_bar, w_peak, w_valley2_bar, w_valley2, color=color.green, width=line_width + 1, style=line.style_solid)

    if show_pattern_labels
        label.new(w_valley2_bar, w_valley2 - atr_14 * 0.5,
                 "🟢 W " + w_type + "\n" + str.tostring(w_valley2, "#.#####"),
                 style=label.style_label_up, color=color.green, textcolor=color.white, size=label_text_size)

// Nameable Pattern Markers
if evening_star_signal and show_pattern_labels
    label.new(bar_index, high + atr_14 * 0.5, "🌟 EVENING STAR",
             style=label.style_label_down, color=color.purple, textcolor=color.white, size=label_text_size)

if morning_star_signal and show_pattern_labels
    label.new(bar_index, low - atr_14 * 0.5, "🌅 MORNING STAR",
             style=label.style_label_up, color=color.orange, textcolor=color.white, size=label_text_size)

if railroad_signal and show_pattern_labels
    track_text = bearish_tracks ? "🚂 BEARISH TRACKS" : "🚂 BULLISH TRACKS"
    track_color = bearish_tracks ? color.red : color.green
    track_style = bearish_tracks ? label.style_label_down : label.style_label_up
    track_y = bearish_tracks ? high + atr_14 * 0.3 : low - atr_14 * 0.3
    label.new(bar_index, track_y, track_text,
             style=track_style, color=track_color, textcolor=color.white, size=size.small)

if cordofwoods_signal and show_pattern_labels
    cord_text = bullish_cords ? "🪵 BULL CORDS (" + str.tostring(cord_count) + ")" : "🪵 BEAR CORDS (" + str.tostring(cord_count) + ")"
    cord_color = bullish_cords ? color.green : color.red
    cord_style = bullish_cords ? label.style_label_up : label.style_label_down
    cord_y = bullish_cords ? low - atr_14 * 0.2 : high + atr_14 * 0.2
    label.new(bar_index, cord_y, cord_text,
             style=cord_style, color=cord_color, textcolor=color.white, size=size.tiny)

// ============================================================================
// 🎯 PATTERN STRENGTH ASSESSMENT
// ============================================================================

// M Pattern Strength
m_pattern_strength() =>
    if not m_completed
        "NONE"
    else
        strength_score = 0

        // Volume confirmation
        if volume > volume_spike_threshold
            strength_score += 2

        // Pattern symmetry
        if not na(m_peak1) and not na(m_peak2)
            symmetry = math.abs(m_peak1 - m_peak2) / math.max(m_peak1, m_peak2)
            if symmetry < 0.005
                strength_score += 2
            else if symmetry < 0.01
                strength_score += 1

        // Context bonus
        if m_type == "TYPE_1_RESISTANCE"
            strength_score += 1

        if strength_score >= 4
            "ULTIMATE"
        else if strength_score >= 3
            "STRONG"
        else if strength_score >= 2
            "MODERATE"
        else
            "WEAK"

// W Pattern Strength
w_pattern_strength() =>
    if not w_completed
        "NONE"
    else
        strength_score = 0

        // Volume confirmation
        if volume > volume_spike_threshold
            strength_score += 2

        // Pattern symmetry
        if not na(w_valley1) and not na(w_valley2)
            symmetry = math.abs(w_valley1 - w_valley2) / math.max(w_valley1, w_valley2)
            if symmetry < 0.005
                strength_score += 2
            else if symmetry < 0.01
                strength_score += 1

        // Context bonus
        if w_type == "TYPE_1_SUPPORT"
            strength_score += 1

        if strength_score >= 4
            "ULTIMATE"
        else if strength_score >= 3
            "STRONG"
        else if strength_score >= 2
            "MODERATE"
        else
            "WEAK"

m_strength = m_pattern_strength()
w_strength = w_pattern_strength()

// ============================================================================
// 📊 DATA WINDOW OUTPUTS (FOR INTEGRATION)
// ============================================================================

plot(m_completed ? 1 : 0, "M_Pattern_Complete", display=display.data_window)
plot(w_completed ? 1 : 0, "W_Pattern_Complete", display=display.data_window)
plot(m_peak1, "M_Peak1", display=display.data_window)
plot(m_peak2, "M_Peak2", display=display.data_window)
plot(m_valley, "M_Valley", display=display.data_window)
plot(w_valley1, "W_Valley1", display=display.data_window)
plot(w_valley2, "W_Valley2", display=display.data_window)
plot(w_peak, "W_Peak", display=display.data_window)
plot(evening_star_signal ? 1 : 0, "Evening_Star", display=display.data_window)
plot(morning_star_signal ? 1 : 0, "Morning_Star", display=display.data_window)
plot(railroad_signal ? 1 : 0, "Railroad_Tracks", display=display.data_window)
plot(bearish_tracks ? 1 : 0, "Bearish_Tracks", display=display.data_window)
plot(bullish_tracks ? 1 : 0, "Bullish_Tracks", display=display.data_window)
plot(cordofwoods_signal ? 1 : 0, "Cordofwoods", display=display.data_window)
plot(bullish_cords ? 1 : 0, "Bullish_Cords", display=display.data_window)
plot(bearish_cords ? 1 : 0, "Bearish_Cords", display=display.data_window)
plot(cord_count, "Cord_Count", display=display.data_window)
plot(volume_ratio, "Volume_Ratio", display=display.data_window)

// Pattern strength outputs
plot(m_strength == "ULTIMATE" ? 4 : m_strength == "STRONG" ? 3 : m_strength == "MODERATE" ? 2 : m_strength == "WEAK" ? 1 : 0, "M_Strength", display=display.data_window)
plot(w_strength == "ULTIMATE" ? 4 : w_strength == "STRONG" ? 3 : w_strength == "MODERATE" ? 2 : w_strength == "WEAK" ? 1 : 0, "W_Strength", display=display.data_window)

// ============================================================================
// 🏛️ ADVANCED INSTITUTIONAL PATTERNS
// ============================================================================
// Advanced patterns from BTMM_Advanced_Patterns.pine merged in
// Author: BTMM Development Team - Advanced Pattern Module
// ============================================================================

// Advanced Pattern Settings
var g_ADVANCED = "🏛️ ADVANCED INSTITUTIONAL PATTERNS"
enable_order_blocks   = input.bool(true,  "Enable Order Block Detection",   group=g_ADVANCED)
enable_fvg_detection  = input.bool(true,  "Enable Fair Value Gap Detection", group=g_ADVANCED)
enable_bos_patterns   = input.bool(true,  "Enable Break of Structure",      group=g_ADVANCED)
enable_v1_v2_patterns = input.bool(true,  "Enable V1/V2 Day 2 Patterns",    group=g_ADVANCED)
enable_a1_a2_patterns = input.bool(true,  "Enable A1/A2 Day 3 Patterns",    group=g_ADVANCED)

// Advanced Confluence Settings
var g_ADV_CONFLUENCE = "🔗 ADVANCED CONFLUENCE"
require_htf_bias      = input.bool(true,  "Require HTF Bias Confluence",    group=g_ADV_CONFLUENCE)
require_ema_stack     = input.bool(true,  "Require EMA Stack Confluence",   group=g_ADV_CONFLUENCE)
require_volume_conf   = input.bool(true,  "Require Volume Confirmation",    group=g_ADV_CONFLUENCE)
min_pattern_strength  = input.float(70.0, "Minimum Pattern Strength", minval=0.0, maxval=100.0, group=g_ADV_CONFLUENCE)

// Order Block Settings
var g_OB = "📦 ORDER BLOCK SETTINGS"
ob_min_body_size     = input.float(0.5, "Min Body Size (ATR)",     minval=0.1, maxval=2.0, group=g_OB)
ob_max_wick_size     = input.float(0.3, "Max Wick Size (ATR)",     minval=0.1, maxval=1.0, group=g_OB)
ob_lookback_bars     = input.int(10,    "Order Block Lookback",    minval=5,   maxval=50,  group=g_OB)

// Fair Value Gap Settings
var g_FVG = "🌉 FAIR VALUE GAP SETTINGS"
fvg_min_size         = input.float(0.2, "Min FVG Size (ATR)",     minval=0.1, maxval=1.0, group=g_FVG)
fvg_max_lookback     = input.int(20,    "FVG Lookback Bars",      minval=10,  maxval=100, group=g_FVG)

// Advanced Visual Settings
var g_ADV_VISUAL = "🎨 ADVANCED VISUALS"
show_order_blocks    = input.bool(true,  "Show Order Blocks",         group=g_ADV_VISUAL)
show_fair_value_gaps = input.bool(true,  "Show Fair Value Gaps",      group=g_ADV_VISUAL)
show_structure_lines = input.bool(true,  "Show Structure Lines",      group=g_ADV_VISUAL)

// Advanced Colors
bull_ob_color    = input.color(color.new(color.green, 80), "Bullish Order Block", group=g_ADV_VISUAL)
bear_ob_color    = input.color(color.new(color.red, 80),   "Bearish Order Block", group=g_ADV_VISUAL)
bull_fvg_color   = input.color(color.new(color.blue, 85),  "Bullish FVG",         group=g_ADV_VISUAL)
bear_fvg_color   = input.color(color.new(color.orange, 85), "Bearish FVG",        group=g_ADV_VISUAL)

// HTF Bias Integration
htf_ema_direction = request.security(syminfo.tickerid, "240",
  bull_stack ? 1 : bear_stack ? -1 : 0, lookahead=barmerge.lookahead_off)
htf_bias_bull = htf_ema_direction > 0
htf_bias_bear = htf_ema_direction < 0

// Order Block Detection
is_strong_bear_candle = close < open and (open - close) >= (atr_14 * ob_min_body_size) and
  math.min(open - high, close - low) <= (atr_14 * ob_max_wick_size)

is_strong_bull_candle = close > open and (close - open) >= (atr_14 * ob_min_body_size) and
  math.min(high - close, low - open) <= (atr_14 * ob_max_wick_size)

// Order block arrays
var array<box> bull_order_blocks = array.new<box>()
var array<box> bear_order_blocks = array.new<box>()

// Detect bullish order blocks
bull_ob_signal = is_strong_bear_candle and low[1] < ta.lowest(low, ob_lookback_bars) and
  close > high[1]  // Price reversal above the bearish candle

// Detect bearish order blocks
bear_ob_signal = is_strong_bull_candle and high[1] > ta.highest(high, ob_lookback_bars) and
  close < low[1]  // Price reversal below the bullish candle

// Create order block boxes
if bull_ob_signal and show_order_blocks
    ob_box = box.new(bar_index[1], high[1], bar_index + 10, low[1],
      border_color=color.green, bgcolor=bull_ob_color, border_width=1)
    array.push(bull_order_blocks, ob_box)
    if array.size(bull_order_blocks) > 10
        box.delete(array.shift(bull_order_blocks))

if bear_ob_signal and show_order_blocks
    ob_box = box.new(bar_index[1], high[1], bar_index + 10, low[1],
      border_color=color.red, bgcolor=bear_ob_color, border_width=1)
    array.push(bear_order_blocks, ob_box)
    if array.size(bear_order_blocks) > 10
        box.delete(array.shift(bear_order_blocks))

// Fair Value Gap Detection
bull_fvg = low > high[2] and low[1] > high[2] and (low - high[2]) >= (atr_14 * fvg_min_size)
bear_fvg = high < low[2] and high[1] < low[2] and (low[2] - high) >= (atr_14 * fvg_min_size)

// FVG arrays
var array<box> bull_fvgs = array.new<box>()
var array<box> bear_fvgs = array.new<box>()

// Create FVG boxes
if bull_fvg and show_fair_value_gaps
    fvg_box = box.new(bar_index[2], low, bar_index + 20, high[2],
      border_color=color.blue, bgcolor=bull_fvg_color, border_width=1)
    array.push(bull_fvgs, fvg_box)
    if array.size(bull_fvgs) > 10
        box.delete(array.shift(bull_fvgs))

if bear_fvg and show_fair_value_gaps
    fvg_box = box.new(bar_index[2], high, bar_index + 20, low[2],
      border_color=color.orange, bgcolor=bear_fvg_color, border_width=1)
    array.push(bear_fvgs, fvg_box)
    if array.size(bear_fvgs) > 10
        box.delete(array.shift(bear_fvgs))

// Break of Structure Detection
hh = high > ta.highest(high[1], 20) and volume_ratio > volume_spike_threshold
ll = low < ta.lowest(low[1], 20) and volume_ratio > volume_spike_threshold

// Break of Structure patterns
bull_bos = hh and bull_stack and (not require_htf_bias or htf_bias_bull)
bear_bos = ll and bear_stack and (not require_htf_bias or htf_bias_bear)

// V1/V2 Day 2 Patterns (Steve Mauro Methodology)
v1_day2_setup = enable_v1_v2_patterns and cycle_day == 2 and
  bull_stack and htf_bias_bull and volume_ratio > volume_spike_threshold and
  (london_session or ny_session)

v2_day2_setup = enable_v1_v2_patterns and cycle_day == 2 and
  bear_stack and htf_bias_bear and volume_ratio > volume_spike_threshold and
  (london_session or ny_session)

// A1/A2 Day 3 Patterns (Steve Mauro Methodology)
a1_day3_setup = enable_a1_a2_patterns and cycle_day == 3 and
  bull_stack and close > ema50 and volume_ratio > volume_spike_threshold and
  (bull_ob_signal or bull_fvg or bull_bos)

a2_day3_setup = enable_a1_a2_patterns and cycle_day == 3 and
  bear_stack and close < ema50 and volume_ratio > volume_spike_threshold and
  (bear_ob_signal or bear_fvg or bear_bos)

// Pattern Strength Calculation
calc_pattern_strength(base_strength) =>
    strength = base_strength
    strength += require_htf_bias and htf_bias_bull ? 15 : require_htf_bias and htf_bias_bear ? 15 : 0
    strength += require_ema_stack and (bull_stack or bear_stack) ? 20 : 0
    strength += require_volume_conf and volume_ratio > volume_spike_threshold ? 15 : 0
    strength += (london_session or ny_session) ? 10 : 0
    math.min(strength, 100)

// Master Advanced Pattern Signals
bull_advanced_pattern = (v1_day2_setup or a1_day3_setup or bull_bos or bull_ob_signal) and
  calc_pattern_strength(60) >= min_pattern_strength

bear_advanced_pattern = (v2_day2_setup or a2_day3_setup or bear_bos or bear_ob_signal) and
  calc_pattern_strength(60) >= min_pattern_strength

// Advanced Pattern Labels
if show_pattern_labels
    // V1/V2 Day 2 labels
    if v1_day2_setup
        label.new(bar_index, low - atr_14, "🎯 V1 DAY 2",
          style=label.style_label_up, color=color.green,
          textcolor=color.white, size=size.small)

    if v2_day2_setup
        label.new(bar_index, high + atr_14, "🎯 V2 DAY 2",
          style=label.style_label_down, color=color.red,
          textcolor=color.white, size=size.small)

    // A1/A2 Day 3 labels
    if a1_day3_setup
        label.new(bar_index, low - atr_14, "⚡ A1 DAY 3",
          style=label.style_label_up, color=color.lime,
          textcolor=color.black, size=size.small)

    if a2_day3_setup
        label.new(bar_index, high + atr_14, "⚡ A2 DAY 3",
          style=label.style_label_down, color=color.orange,
          textcolor=color.white, size=size.small)

    // Break of Structure labels
    if bull_bos
        label.new(bar_index, low - atr_14 * 0.5, "📈 BULL BOS",
          style=label.style_label_up, color=color.blue,
          textcolor=color.white, size=size.tiny)

    if bear_bos
        label.new(bar_index, high + atr_14 * 0.5, "📉 BEAR BOS",
          style=label.style_label_down, color=color.purple,
          textcolor=color.white, size=size.tiny)

    // Order Block labels
    if bull_ob_signal
        label.new(bar_index[1], high[1] + atr_14 * 0.3, "📦 BULL OB",
          style=label.style_label_down, color=color.green,
          textcolor=color.white, size=size.tiny)

    if bear_ob_signal
        label.new(bar_index[1], low[1] - atr_14 * 0.3, "📦 BEAR OB",
          style=label.style_label_up, color=color.red,
          textcolor=color.white, size=size.tiny)

// ============================================================================
// 📊 ADVANCED DATA WINDOW OUTPUTS (FOR INTEGRATION)
// ============================================================================
plot(bull_advanced_pattern ? 1 : 0, "Bull_Advanced_Pattern", display=display.data_window)
plot(bear_advanced_pattern ? 1 : 0, "Bear_Advanced_Pattern", display=display.data_window)
plot(v1_day2_setup ? 1 : 0, "V1_Day2", display=display.data_window)
plot(v2_day2_setup ? 1 : 0, "V2_Day2", display=display.data_window)
plot(a1_day3_setup ? 1 : 0, "A1_Day3", display=display.data_window)
plot(a2_day3_setup ? 1 : 0, "A2_Day3", display=display.data_window)
plot(bull_ob_signal ? 1 : 0, "Bull_Order_Block", display=display.data_window)
plot(bear_ob_signal ? 1 : 0, "Bear_Order_Block", display=display.data_window)
plot(bull_fvg ? 1 : 0, "Bull_FVG", display=display.data_window)
plot(bear_fvg ? 1 : 0, "Bear_FVG", display=display.data_window)
plot(bull_bos ? 1 : 0, "Bull_BOS", display=display.data_window)
plot(bear_bos ? 1 : 0, "Bear_BOS", display=display.data_window)
plot(calc_pattern_strength(60), "Advanced_Pattern_Strength", display=display.data_window)
// ============================================================================
// MERGED FROM: BTMM_MW_Patterns
// ============================================================================

// ═══════════════════════════════════════════════════════════════════════════════════
// 📈 BTMM M&W PATTERN DETECTION - SCRIPT 3 OF 10
// Steve Mauro's Beat The Market Maker Methodology
// Focus: Second Leg M&W Patterns, 13 EMA Confirmation, Pattern Validation
// ═══════════════════════════════════════════════════════════════════════════════════

import TradingView/ta/7 as ta

// === M&W PATTERN DETECTION WITH SIMPLIFIED 13 EMA CONFIRMATION
// User's Method: Clean close above/below 13 EMA at second leg top/bottom
// ═══════════════════════════════════════════════════════════════════════════════════

// === ENHANCED PATTERN CONFIGURATION ===
pattern_group = "📈 M&W Pattern Detection"
enable_m_patterns = input.bool(true, "Enable M Patterns (Bearish)", group=pattern_group)
enable_w_patterns = input.bool(true, "Enable W Patterns (Bullish)", group=pattern_group)
enable_second_leg_only = input.bool(true, "Second Leg Focus (Steve Mauro)", group=pattern_group)
pattern_lookback = input.int(15, "Pattern Detection Lookback", minval=8, maxval=30, group=pattern_group)
pattern_tolerance = input.float(0.002, "Pattern Tolerance %", minval=0.001, maxval=0.01, step=0.001, group=pattern_group)

// === USER'S SIMPLIFIED CONFIRMATION METHOD ===
confirmation_group = "✅ User's Simplified Method"
simple_ema_confirmation = input.bool(true, "Simple 13 EMA Close Confirmation", group=confirmation_group, tooltip="User's method: Clean close above/below 13 EMA")
require_volume_confirmation = input.bool(true, "Require Volume Confirmation", group=confirmation_group)
min_pattern_height = input.float(0.5, "Minimum Pattern Height (ATR)", minval=0.2, maxval=2.0, step=0.1, group=confirmation_group)

// === VISUAL SETTINGS ===
visual_group = "🎨 Visual Configuration"
show_pattern_labels = input.bool(true, "Show Pattern Labels", group=visual_group)
show_entry_zones = input.bool(true, "Show Entry Zones", group=visual_group)
show_pattern_structure = input.bool(true, "Show Pattern Structure Lines", group=visual_group)
label_size_setting = input.string("normal", "Label Size", options=["tiny", "small", "normal", "large"], group=visual_group)
pattern_line_width = input.int(2, "Pattern Line Width", minval=1, maxval=5, group=visual_group)

// === ALERT CONFIGURATION ===
alert_group = "🚨 M&W Alert Settings"
enable_pattern_alerts = input.bool(true, "Pattern Formation Alerts", group=alert_group)
enable_second_leg_alerts = input.bool(true, "Second Leg Entry Alerts", group=alert_group)
enable_confirmation_alerts = input.bool(true, "Pattern Confirmation Alerts", group=alert_group)
alert_frequency = input.string("once_per_bar", "Alert Frequency", options=["once_per_bar", "once_per_bar_close"], group=alert_group)

// === EARLY ENTRY NAMABLE PATTERNS ===
early_entry_group = "🔍 Early Entry Namable Patterns"
enable_early_entries = input.bool(true, "Enable Early Entry Patterns", group=early_entry_group)
enable_flag_patterns = input.bool(true, "Flag Patterns", group=early_entry_group)
enable_pennant_patterns = input.bool(true, "Pennant Patterns", group=early_entry_group)
enable_rectangle_patterns = input.bool(true, "Rectangle/Channel Patterns", group=early_entry_group)
enable_triangle_patterns = input.bool(true, "Triangle Patterns", group=early_entry_group)
early_entry_bars = input.int(8, "Early Entry Pattern Bars", minval=4, maxval=15, group=early_entry_group)

// ═══════════════════════════════════════════════════════════════════════════════════
// 📊 HELPER FUNCTIONS AND CALCULATIONS
// ═══════════════════════════════════════════════════════════════════════════════════

// EMA 13 for confirmation (Ketchup Line)
ema_13 = ta.ema(close, 13)

// ATR for pattern height validation
atr_value = ta.atr(14)

// Volume analysis
avg_volume = ta.sma(volume, 20)
volume_spike = volume > avg_volume * 1.5

// Pivot detection
pivot_high = ta.pivothigh(high, pattern_lookback, pattern_lookback)
pivot_low = ta.pivotlow(low, pattern_lookback, pattern_lookback)

// ═══════════════════════════════════════════════════════════════════════════════════
// 📈 M PATTERN DETECTION (BEARISH REVERSAL)
// ═══════════════════════════════════════════════════════════════════════════════════

detect_m_pattern() =>
    var float left_shoulder_high = na
    var float head_high = na
    var float right_shoulder_high = na
    var int left_shoulder_bar = na
    var int head_bar = na
    var int right_shoulder_bar = na
    var bool m_pattern_active = false
    var bool second_leg_triggered = false

    // Look for pivot highs to form M pattern
    if not na(pivot_high)
        current_high = pivot_high
        current_bar = bar_index[pattern_lookback]

        // Initialize or update pattern points
        if na(left_shoulder_high)
            left_shoulder_high := current_high
            left_shoulder_bar := current_bar
        else if na(head_high) and current_high > left_shoulder_high
            head_high := current_high
            head_bar := current_bar
        else if na(right_shoulder_high) and not na(head_high) and current_high < head_high
            right_shoulder_high := current_high
            right_shoulder_bar := current_bar

            // Validate M pattern structure
            shoulder_symmetry = math.abs(left_shoulder_high - right_shoulder_high) / head_high <= pattern_tolerance
            pattern_height = head_high - math.min(left_shoulder_high, right_shoulder_high)
            sufficient_height = pattern_height >= atr_value * min_pattern_height

            if shoulder_symmetry and sufficient_height
                m_pattern_active := true

    // User's Simplified Second Leg Detection (Clean 13 EMA Close)
    if m_pattern_active and enable_second_leg_only and not second_leg_triggered
        // User's Method: Simple close below 13 EMA at second leg top
        if simple_ema_confirmation
            // Clean break below 13 EMA with close (user's preferred method)
            ema_break_confirmed = close < ema_13 and close[1] >= ema_13
            if ema_break_confirmed and (not require_volume_confirmation or volume_spike)
                second_leg_triggered := true
        else
            // Original neckline method (backup)
            neckline_level = math.min(left_shoulder_high, right_shoulder_high)
            if close < neckline_level and close < ema_13
                second_leg_triggered := true

    // Reset pattern if invalidated
    if m_pattern_active and high > head_high
        left_shoulder_high := na
        head_high := na
        right_shoulder_high := na
        m_pattern_active := false
        second_leg_triggered := false

    [m_pattern_active, second_leg_triggered, left_shoulder_high, head_high, right_shoulder_high, left_shoulder_bar, head_bar, right_shoulder_bar]

[m_pattern_formed, m_second_leg_active, m_left_shoulder, m_head, m_right_shoulder, m_left_bar, m_head_bar, m_right_bar] = detect_m_pattern()

// ═══════════════════════════════════════════════════════════════════════════════════
// 📉 W PATTERN DETECTION (BULLISH REVERSAL)
// ═══════════════════════════════════════════════════════════════════════════════════

detect_w_pattern() =>
    var float left_shoulder_low = na
    var float head_low = na
    var float right_shoulder_low = na
    var int left_shoulder_bar = na
    var int head_bar = na
    var int right_shoulder_bar = na
    var bool w_pattern_active = false
    var bool second_leg_triggered = false

    // Look for pivot lows to form W pattern
    if not na(pivot_low)
        current_low = pivot_low
        current_bar = bar_index[pattern_lookback]

        // Initialize or update pattern points
        if na(left_shoulder_low)
            left_shoulder_low := current_low
            left_shoulder_bar := current_bar
        else if na(head_low) and current_low < left_shoulder_low
            head_low := current_low
            head_bar := current_bar
        else if na(right_shoulder_low) and not na(head_low) and current_low > head_low
            right_shoulder_low := current_low
            right_shoulder_bar := current_bar

            // Validate W pattern structure
            shoulder_symmetry = math.abs(left_shoulder_low - right_shoulder_low) / head_low <= pattern_tolerance
            pattern_height = math.max(left_shoulder_low, right_shoulder_low) - head_low
            sufficient_height = pattern_height >= atr_value * min_pattern_height

            if shoulder_symmetry and sufficient_height
                w_pattern_active := true

    // User's Simplified Second Leg Detection (Clean 13 EMA Close)
    if w_pattern_active and enable_second_leg_only and not second_leg_triggered
        // User's Method: Simple close above 13 EMA at second leg bottom
        if simple_ema_confirmation
            // Clean break above 13 EMA with close (user's preferred method)
            ema_break_confirmed = close > ema_13 and close[1] <= ema_13
            if ema_break_confirmed and (not require_volume_confirmation or volume_spike)
                second_leg_triggered := true
        else
            // Original neckline method (backup)
            neckline_level = math.max(left_shoulder_low, right_shoulder_low)
            if close > neckline_level and close > ema_13
                second_leg_triggered := true

    // Reset pattern if invalidated
    if w_pattern_active and low < head_low
        left_shoulder_low := na
        head_low := na
        right_shoulder_low := na
        w_pattern_active := false
        second_leg_triggered := false

    [w_pattern_active, second_leg_triggered, left_shoulder_low, head_low, right_shoulder_low, left_shoulder_bar, head_bar, right_shoulder_bar]

[w_pattern_formed, w_second_leg_active, w_left_shoulder, w_head, w_right_shoulder, w_left_bar, w_head_bar, w_right_bar] = detect_w_pattern()

// ═══════════════════════════════════════════════════════════════════════════════════
// ✅ PATTERN CONFIRMATION AND CONFLUENCE
// ═══════════════════════════════════════════════════════════════════════════════════

calculate_confluence_score(pattern_type) =>
    score = 0

    // User's Simplified 13 EMA Confirmation (Primary Factor)
    if simple_ema_confirmation
        if pattern_type == "M" and close < ema_13
            score += 2  // Higher weight for user's primary method
        else if pattern_type == "W" and close > ema_13
            score += 2  // Higher weight for user's primary method
    else
        // Traditional EMA confirmation (backup method)
        if pattern_type == "M" and close < ema_13
            score += 1
        else if pattern_type == "W" and close > ema_13
            score += 1

    // Volume Confirmation
    if require_volume_confirmation and volume_spike
        score += 1

    // Price action confluence (clean candle close)
    if pattern_type == "M" and close < open  // Bearish candle
        score += 1
    else if pattern_type == "W" and close > open  // Bullish candle
        score += 1

    // Early Entry Pattern Bonus
    if early_entry_signal
        score += 1

    score

m_confluence_score = m_pattern_formed ? calculate_confluence_score("M") : 0
w_confluence_score = w_pattern_formed ? calculate_confluence_score("W") : 0

// Simplified confirmation requirements (user's preference)
confluence_threshold = simple_ema_confirmation ? 2 : 3  // Lower threshold for user's method
m_pattern_confirmed = m_pattern_formed and m_confluence_score >= confluence_threshold
w_pattern_confirmed = w_pattern_formed and w_confluence_score >= confluence_threshold

// ═══════════════════════════════════════════════════════════════════════════════════
// 🎨 VISUAL PATTERN DISPLAY
// ═══════════════════════════════════════════════════════════════════════════════════

label_size = switch label_size_setting
    "tiny" => size.tiny
    "small" => size.small
    "normal" => size.normal
    "large" => size.large
    => size.normal

// M Pattern Visualization
if show_pattern_structure and enable_m_patterns and m_pattern_formed and not na(m_left_shoulder) and not na(m_head) and not na(m_right_shoulder)
    // Draw pattern structure lines
    line.new(m_left_bar, m_left_shoulder, m_head_bar, m_head, color=color.red, width=pattern_line_width, style=line.style_solid)
    line.new(m_head_bar, m_head, m_right_bar, m_right_shoulder, color=color.red, width=pattern_line_width, style=line.style_solid)

    // Draw neckline
    neckline = math.min(m_left_shoulder, m_right_shoulder)
    line.new(m_left_bar, neckline, m_right_bar, neckline, color=color.orange, width=1, style=line.style_dashed)

// W Pattern Visualization
if show_pattern_structure and enable_w_patterns and w_pattern_formed and not na(w_left_shoulder) and not na(w_head) and not na(w_right_shoulder)
    // Draw pattern structure lines
    line.new(w_left_bar, w_left_shoulder, w_head_bar, w_head, color=color.green, width=pattern_line_width, style=line.style_solid)
    line.new(w_head_bar, w_head, w_right_bar, w_right_shoulder, color=color.green, width=pattern_line_width, style=line.style_solid)

    // Draw neckline
    neckline = math.max(w_left_shoulder, w_right_shoulder)
    line.new(w_left_bar, neckline, w_right_bar, neckline, color=color.lime, width=1, style=line.style_dashed)

// Pattern Labels
if show_pattern_labels
    if m_pattern_confirmed and not m_pattern_confirmed[1]
        label.new(bar_index, high + atr_value,
                  "🔻 M PATTERN\n" + (m_second_leg_active ? "2ND LEG" : "FORMING") +
                  "\nConfluence: " + str.tostring(m_confluence_score) + "/" + str.tostring(confluence_threshold),
                  style=label.style_label_down, color=color.red, textcolor=color.white, size=label_size)

    if w_pattern_confirmed and not w_pattern_confirmed[1]
        label.new(bar_index, low - atr_value,
                  "🔺 W PATTERN\n" + (w_second_leg_active ? "2ND LEG" : "FORMING") +
                  "\nConfluence: " + str.tostring(w_confluence_score) + "/" + str.tostring(confluence_threshold),
                  style=label.style_label_up, color=color.green, textcolor=color.white, size=label_size)

// Entry Zone Visualization
if show_entry_zones
    if m_second_leg_active and not na(m_right_shoulder)
        entry_zone_top = m_right_shoulder
        entry_zone_bottom = m_right_shoulder * (1 - pattern_tolerance)
        box.new(bar_index - 5, entry_zone_top, bar_index + 5, entry_zone_bottom,
                bgcolor=color.new(color.red, 80), border_color=color.red, border_width=1)

    if w_second_leg_active and not na(w_right_shoulder)
        entry_zone_bottom = w_right_shoulder
        entry_zone_top = w_right_shoulder * (1 + pattern_tolerance)
        box.new(bar_index - 5, entry_zone_top, bar_index + 5, entry_zone_bottom,
                bgcolor=color.new(color.green, 80), border_color=color.green, border_width=1)

// ═══════════════════════════════════════════════════════════════════════════════════
// 📊 M&W PATTERN STATUS TABLE
// ═══════════════════════════════════════════════════════════════════════════════════

if barstate.islast
    var table pattern_table = table.new(position.bottom_right, 3, 6, bgcolor=color.new(color.white, 10), border_width=2)

    // Header
    table.cell(pattern_table, 0, 0, "M&W PATTERNS", bgcolor=color.navy, text_color=color.white, text_size=size.normal)
    table.cell(pattern_table, 1, 0, "STATUS", bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(pattern_table, 2, 0, "CONFLUENCE", bgcolor=color.gray, text_color=color.white, text_size=size.normal)

    // M Pattern Status
    m_status_color = m_pattern_confirmed ? color.new(color.red, 50) : m_pattern_formed ? color.new(color.orange, 70) : color.new(color.gray, 80)
    m_status_text = m_pattern_confirmed ? "✅ CONFIRMED" : m_pattern_formed ? "⏳ FORMING" : "❌ NONE"
    table.cell(pattern_table, 0, 1, "M Pattern", bgcolor=color.red, text_color=color.white)
    table.cell(pattern_table, 1, 1, m_status_text, bgcolor=m_status_color, text_color=color.white)
    table.cell(pattern_table, 2, 1, str.tostring(m_confluence_score) + "/" + str.tostring(confluence_threshold), bgcolor=m_status_color, text_color=color.white)

    // W Pattern Status
    w_status_color = w_pattern_confirmed ? color.new(color.green, 50) : w_pattern_formed ? color.new(color.lime, 70) : color.new(color.gray, 80)
    w_status_text = w_pattern_confirmed ? "✅ CONFIRMED" : w_pattern_formed ? "⏳ FORMING" : "❌ NONE"
    table.cell(pattern_table, 0, 2, "W Pattern", bgcolor=color.green, text_color=color.white)
    table.cell(pattern_table, 1, 2, w_status_text, bgcolor=w_status_color, text_color=color.white)
    table.cell(pattern_table, 2, 2, str.tostring(w_confluence_score) + "/" + str.tostring(confluence_threshold), bgcolor=w_status_color, text_color=color.white)

    // Second Leg Status
    second_leg_status = m_second_leg_active ? "🔻 M 2ND LEG" : w_second_leg_active ? "🔺 W 2ND LEG" : "❌ NO ACTIVE"
    second_leg_color = m_second_leg_active ? color.new(color.red, 50) : w_second_leg_active ? color.new(color.green, 50) : color.new(color.gray, 80)
    table.cell(pattern_table, 0, 3, "Second Leg", bgcolor=color.purple, text_color=color.white)
    table.cell(pattern_table, 1, 3, second_leg_status, bgcolor=second_leg_color, text_color=color.white)
    table.cell(pattern_table, 2, 3, enable_second_leg_only ? "✅ ENABLED" : "❌ DISABLED", bgcolor=second_leg_color, text_color=color.white)

    // EMA 13 Confirmation
    ema_status = close > ema_13 ? "🔺 ABOVE" : "🔻 BELOW"
    ema_color = close > ema_13 ? color.new(color.green, 70) : color.new(color.red, 70)
    table.cell(pattern_table, 0, 4, "EMA 13", bgcolor=color.orange, text_color=color.white)
    table.cell(pattern_table, 1, 4, ema_status, bgcolor=ema_color, text_color=color.white)
    table.cell(pattern_table, 2, 4, str.tostring(ema_13, "#.#####"), bgcolor=ema_color, text_color=color.white)

    // Volume Analysis
    vol_status = volume_spike ? "🔥 SPIKE" : "📊 NORMAL"
    vol_color = volume_spike ? color.new(color.yellow, 50) : color.new(color.gray, 70)
    table.cell(pattern_table, 0, 5, "Volume", bgcolor=color.blue, text_color=color.white)
    table.cell(pattern_table, 1, 5, vol_status, bgcolor=vol_color, text_color=color.white)
    table.cell(pattern_table, 2, 5, str.tostring(volume / avg_volume, "#.#") + "x Avg", bgcolor=vol_color, text_color=color.white)

// Early Entry Pattern Labels and Alerts
if show_pattern_labels and enable_candlestick_patterns
    // Convert label size
    pattern_label_size_converted = switch pattern_label_size
        "tiny" => size.tiny
        "small" => size.small
        "large" => size.large
        => size.normal

    // === BULLISH CANDLESTICK PATTERNS ===

    // Single Candle Bullish
    if hammer
        label.new(bar_index, low, "🔨\nHAMMER", style=label.style_label_up, color=color.green, textcolor=color.white, size=pattern_label_size_converted)

    if inverted_hammer
        label.new(bar_index, high, "🔨\nINV HAMMER", style=label.style_label_down, color=color.green, textcolor=color.white, size=pattern_label_size_converted)

    if dragonfly_doji
        label.new(bar_index, low, "🐉\nDRAGONFLY", style=label.style_label_up, color=color.blue, textcolor=color.white, size=pattern_label_size_converted)

    // Two Candle Bullish
    if railroad_bull
        label.new(bar_index, low, "🚂\nRAILROAD\nBULL", style=label.style_label_up, color=color.lime, textcolor=color.black, size=pattern_label_size_converted)

    if bullish_engulfing
        label.new(bar_index, low, "🫂\nBULL\nENGULF", style=label.style_label_up, color=color.green, textcolor=color.white, size=pattern_label_size_converted)

    if bullish_harami
        label.new(bar_index, low, "🤱\nBULL\nHARAMI", style=label.style_label_up, color=color.aqua, textcolor=color.white, size=pattern_label_size_converted)

    // Three Candle Bullish
    if morning_star
        label.new(bar_index, low, "⭐\nMORNING\nSTAR", style=label.style_label_up, color=color.yellow, textcolor=color.black, size=pattern_label_size_converted)

    if morning_doji_star
        label.new(bar_index, low, "⭐\nMORN DOJI\nSTAR", style=label.style_label_up, color=color.orange, textcolor=color.white, size=pattern_label_size_converted)

    if three_white_soldiers
        label.new(bar_index, low, "⚔️\nTHREE\nSOLDIERS", style=label.style_label_up, color=color.lime, textcolor=color.black, size=pattern_label_size_converted)

    // === BEARISH CANDLESTICK PATTERNS ===

    // Single Candle Bearish
    if shooting_star
        label.new(bar_index, high, "⭐\nSHOOTING\nSTAR", style=label.style_label_down, color=color.red, textcolor=color.white, size=pattern_label_size_converted)

    if hanging_man
        label.new(bar_index, high, "🪓\nHANGING\nMAN", style=label.style_label_down, color=color.maroon, textcolor=color.white, size=pattern_label_size_converted)

    if gravestone_doji
        label.new(bar_index, high, "🪦\nGRAVESTONE", style=label.style_label_down, color=color.purple, textcolor=color.white, size=pattern_label_size_converted)

    // Two Candle Bearish
    if railroad_bear
        label.new(bar_index, high, "🚂\nRAILROAD\nBEAR", style=label.style_label_down, color=color.red, textcolor=color.white, size=pattern_label_size_converted)

    if bearish_engulfing
        label.new(bar_index, high, "🫂\nBEAR\nENGULF", style=label.style_label_down, color=color.red, textcolor=color.white, size=pattern_label_size_converted)

    if bearish_harami
        label.new(bar_index, high, "🤱\nBEAR\nHARAMI", style=label.style_label_down, color=color.orange, textcolor=color.white, size=pattern_label_size_converted)

    // Three Candle Bearish
    if evening_star
        label.new(bar_index, high, "🌅\nEVENING\nSTAR", style=label.style_label_down, color=color.orange, textcolor=color.white, size=pattern_label_size_converted)

    if evening_doji_star
        label.new(bar_index, high, "🌅\nEVE DOJI\nSTAR", style=label.style_label_down, color=color.red, textcolor=color.white, size=pattern_label_size_converted)

    if three_black_crows
        label.new(bar_index, high, "🐦\nTHREE\nCROWS", style=label.style_label_down, color=color.black, textcolor=color.white, size=pattern_label_size_converted)

    // === NEUTRAL/SPECIAL PATTERNS ===

    if doji
        label.new(bar_index, high, "✚\nDOJI", style=label.style_label_center, color=color.gray, textcolor=color.white, size=pattern_label_size_converted)

    if cord_of_wood
        label.new(bar_index, math.avg(high, low), "🪵\nCORD OF\nWOOD", style=label.style_label_center, color=color.brown, textcolor=color.white, size=pattern_label_size_converted)

    if spinning_top
        label.new(bar_index, math.avg(high, low), "🌪️\nSPIN TOP", style=label.style_label_center, color=color.gray, textcolor=color.white, size=pattern_label_size_converted)

    // === RARE PATTERNS (if enabled) ===

    if show_rare_patterns
        if abandoned_baby_bull
            label.new(bar_index, low, "👶\nABANDONED\nBABY BULL", style=label.style_label_up, color=color.purple, textcolor=color.white, size=pattern_label_size_converted)

        if abandoned_baby_bear
            label.new(bar_index, high, "👶\nABANDONED\nBABY BEAR", style=label.style_label_down, color=color.purple, textcolor=color.white, size=pattern_label_size_converted)

        if white_marubozu
            label.new(bar_index, low, "💪\nWHITE\nMARUBOZU", style=label.style_label_up, color=color.lime, textcolor=color.black, size=pattern_label_size_converted)

        if black_marubozu
            label.new(bar_index, high, "💪\nBLACK\nMARUBOZU", style=label.style_label_down, color=color.black, textcolor=color.white, size=pattern_label_size_converted)

        if belt_hold_bull
            label.new(bar_index, low, "🥋\nBELT HOLD\nBULL", style=label.style_label_up, color=color.green, textcolor=color.white, size=pattern_label_size_converted)

        if belt_hold_bear
            label.new(bar_index, high, "🥋\nBELT HOLD\nBEAR", style=label.style_label_down, color=color.red, textcolor=color.white, size=pattern_label_size_converted)

    // === EARLY ENTRY CONFIRMATION LABELS ===

    if early_bullish_entry and not early_bullish_entry[1]
        label.new(bar_index, low - atr_value,
                  "🔺 EARLY ENTRY\n" + pattern_name + "\n13 EMA BREAK UP",
                  style=label.style_label_up, color=color.blue, textcolor=color.white, size=label_size)

    if early_bearish_entry and not early_bearish_entry[1]
        label.new(bar_index, high + atr_value,
                  "🔻 EARLY ENTRY\n" + pattern_name + "\n13 EMA BREAK DOWN",
                  style=label.style_label_down, color=color.purple, textcolor=color.white, size=label_size)

// Early Entry Pattern Table Status
if barstate.islast and enable_candlestick_patterns
    // Update pattern table with candlestick patterns
    table.cell(pattern_table, 0, 4, "Candlestick Patterns", bgcolor=color.blue, text_color=color.white)
    pattern_status_text = any_pattern_active ? "✅ " + pattern_name : "❌ NONE"
    pattern_status_color = any_pattern_active ? color.new(color.blue, 50) : color.new(color.gray, 80)
    table.cell(pattern_table, 1, 4, pattern_status_text, bgcolor=pattern_status_color, text_color=color.white)
    table.cell(pattern_table, 2, 4, "13 EMA ENTRY", bgcolor=pattern_status_color, text_color=color.white)

    // Early entry status
    table.cell(pattern_table, 0, 5, "Early Entry", bgcolor=color.purple, text_color=color.white)
    early_entry_text = early_entry_signal ? (early_bullish_entry ? "🔺 BULLISH" : "🔻 BEARISH") : "❌ NONE"
    early_entry_color = early_entry_signal ? color.new(color.purple, 50) : color.new(color.gray, 80)
    table.cell(pattern_table, 1, 5, early_entry_text, bgcolor=early_entry_color, text_color=color.white)
    table.cell(pattern_table, 2, 5, early_entry_signal ? pattern_name : "WAITING", bgcolor=early_entry_color, text_color=color.white)

// ═══════════════════════════════════════════════════════════════════════════════════
// 🚨 CANDLESTICK PATTERN ALERTS + 13 EMA CONFIRMATION
// ═══════════════════════════════════════════════════════════════════════════════════

alert_freq = alert_frequency == "once_per_bar" ? alert.freq_once_per_bar : alert.freq_once_per_bar_close

// M&W Pattern Formation Alerts
if enable_pattern_alerts
    if m_pattern_confirmed and not m_pattern_confirmed[1]
        alert("🔻 M PATTERN CONFIRMED!\n" +
              "Symbol: " + syminfo.ticker + "\n" +
              "Timeframe: " + timeframe.period + "\n" +
              "Pattern Type: BEARISH M\n" +
              "Confluence Score: " + str.tostring(m_confluence_score) + "/" + str.tostring(confluence_threshold) + "\n" +
              "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
              "Second Leg: " + (m_second_leg_active ? "ACTIVE" : "PENDING"), alert_freq)

    if w_pattern_confirmed and not w_pattern_confirmed[1]
        alert("🔺 W PATTERN CONFIRMED!\n" +
              "Symbol: " + syminfo.ticker + "\n" +
              "Timeframe: " + timeframe.period + "\n" +
              "Pattern Type: BULLISH W\n" +
              "Confluence Score: " + str.tostring(w_confluence_score) + "/" + str.tostring(confluence_threshold) + "\n" +
              "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
              "Second Leg: " + (w_second_leg_active ? "ACTIVE" : "PENDING"), alert_freq)

// Second Leg Entry Alerts
if enable_second_leg_alerts
    if m_second_leg_active and not m_second_leg_active[1]
        alert("🎯 M PATTERN SECOND LEG TRIGGERED!\n" +
              "Symbol: " + syminfo.ticker + "\n" +
              "Entry Signal: BEARISH\n" +
              "Price: " + str.tostring(close, "#.#####") + "\n" +
              "Pattern: M Formation\n" +
              "Action: Consider short entry", alert_freq)

    if w_second_leg_active and not w_second_leg_active[1]
        alert("🎯 W PATTERN SECOND LEG TRIGGERED!\n" +
              "Symbol: " + syminfo.ticker + "\n" +
              "Entry Signal: BULLISH\n" +
              "Price: " + str.tostring(close, "#.#####") + "\n" +
              "Pattern: W Formation\n" +
              "Action: Consider long entry", alert_freq)

// Major Reversal Pattern Alerts
if enable_confirmation_alerts and hammer and not hammer[1]
    alert("🔨 HAMMER PATTERN DETECTED\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: HAMMER - Potential Bullish Reversal\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

if enable_confirmation_alerts and shooting_star and not shooting_star[1]
    alert("⭐ SHOOTING STAR PATTERN DETECTED\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: SHOOTING STAR - Potential Bearish Reversal\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

if enable_confirmation_alerts and morning_star and not morning_star[1]
    alert("⭐ MORNING STAR PATTERN DETECTED\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: MORNING STAR - Strong Bullish Reversal\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

if enable_confirmation_alerts and evening_star and not evening_star[1]
    alert("🌅 EVENING STAR PATTERN DETECTED\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: EVENING STAR - Strong Bearish Reversal\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

// Engulfing Pattern Alerts
if enable_confirmation_alerts and bullish_engulfing and not bullish_engulfing[1]
    alert("🫂 BULLISH ENGULFING PATTERN\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: BULLISH ENGULFING - Strong Bullish Signal\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

if enable_confirmation_alerts and bearish_engulfing and not bearish_engulfing[1]
    alert("🫂 BEARISH ENGULFING PATTERN\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: BEARISH ENGULFING - Strong Bearish Signal\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

// Railroad Track Alerts
if enable_confirmation_alerts and railroad_bull and not railroad_bull[1]
    alert("🚂 BULLISH RAILROAD TRACKS\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: RAILROAD TRACKS - Side-by-side Bullish\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

if enable_confirmation_alerts and railroad_bear and not railroad_bear[1]
    alert("🚂 BEARISH RAILROAD TRACKS\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: RAILROAD TRACKS - Side-by-side Bearish\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

// Continuation Pattern Alerts
if enable_confirmation_alerts and three_white_soldiers and not three_white_soldiers[1]
    alert("⚔️ THREE WHITE SOLDIERS\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: THREE WHITE SOLDIERS - Strong Bullish Continuation\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

if enable_confirmation_alerts and three_black_crows and not three_black_crows[1]
    alert("🐦 THREE BLACK CROWS\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: THREE BLACK CROWS - Strong Bearish Continuation\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

// Indecision Pattern Alerts
if enable_confirmation_alerts and doji and not doji[1]
    alert("✚ DOJI PATTERN DETECTED\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: DOJI - Market Indecision\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

if enable_confirmation_alerts and cord_of_wood and not cord_of_wood[1]
    alert("🪵 CORD OF WOOD PATTERN\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: CORD OF WOOD - Extended Indecision\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

// User's Early Entry Pattern Alerts (Pattern + 13 EMA Confirmation)
if enable_confirmation_alerts and early_bullish_entry and not early_bullish_entry[1]
    alert("🔺 EARLY BULLISH ENTRY: " + pattern_name + " + 13 EMA BREAK\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: " + pattern_name + "\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Entry Type: EARLY BULLISH CONFIRMATION\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

if enable_confirmation_alerts and early_bearish_entry and not early_bearish_entry[1]
    alert("🔻 EARLY BEARISH ENTRY: " + pattern_name + " + 13 EMA BREAK\n" +
          "Symbol: " + syminfo.ticker + "\n" +
          "Timeframe: " + timeframe.period + "\n" +
          "Pattern: " + pattern_name + "\n" +
          "EMA 13: " + str.tostring(ema_13, "#.#####") + "\n" +
          "Entry Type: EARLY BEARISH CONFIRMATION\n" +
          "Close: " + str.tostring(close, "#.#####"), alert_freq)

// ═══════════════════════════════════════════════════════════════════════════════════
// 📊 CANDLESTICK PATTERN COUNTERS AND DATA OUTPUTS
// ═══════════════════════════════════════════════════════════════════════════════════

// Basic pattern occurrence tracking
var int hammer_count = 0
var int shooting_star_count = 0
var int morning_star_count = 0
var int evening_star_count = 0
var int engulfing_count = 0
var int railroad_count = 0
var int doji_count = 0

// Count patterns when they occur
if hammer and barstate.isconfirmed
    hammer_count += 1
if shooting_star and barstate.isconfirmed
    shooting_star_count += 1
if morning_star and barstate.isconfirmed
    morning_star_count += 1
if evening_star and barstate.isconfirmed
    evening_star_count += 1
if (bullish_engulfing or bearish_engulfing) and barstate.isconfirmed
    engulfing_count += 1
if (railroad_bull or railroad_bear) and barstate.isconfirmed
    railroad_count += 1
if doji and barstate.isconfirmed
    doji_count += 1

// Display pattern counts in data window
plot(hammer_count, "Hammer Count", color=color.green, display=display.data_window)
plot(shooting_star_count, "Shooting Star Count", color=color.red, display=display.data_window)
plot(morning_star_count, "Morning Star Count", color=color.yellow, display=display.data_window)
plot(evening_star_count, "Evening Star Count", color=color.orange, display=display.data_window)
plot(engulfing_count, "Engulfing Count", color=color.blue, display=display.data_window)
plot(railroad_count, "Railroad Count", color=color.purple, display=display.data_window)
plot(doji_count, "Doji Count", color=color.gray, display=display.data_window)

// Current pattern status (1 = active, 0 = none)
plot(hammer ? 1 : 0, "Current Hammer", color=color.green, display=display.data_window)
plot(shooting_star ? 1 : 0, "Current Shooting Star", color=color.red, display=display.data_window)
plot(railroad_bull ? 1 : 0, "Current Railroad Bull", color=color.lime, display=display.data_window)
plot(railroad_bear ? 1 : 0, "Current Railroad Bear", color=color.red, display=display.data_window)
plot(doji ? 1 : 0, "Current Doji", color=color.gray, display=display.data_window)
plot(cord_of_wood ? 1 : 0, "Current Cord of Wood", color=color.brown, display=display.data_window)

// Early entry signal status
plot(early_bullish_entry ? 1 : 0, "Early Bullish Entry", color=color.blue, display=display.data_window)
plot(early_bearish_entry ? 1 : 0, "Early Bearish Entry", color=color.purple, display=display.data_window)

// ═══════════════════════════════════════════════════════════════════════════════════
// 📊 EXPORT VALUES FOR OTHER SCRIPTS
// ═══════════════════════════════════════════════════════════════════════════════════

// Export user's simplified entry signals
export m_pattern_confirmed
export w_pattern_confirmed
export m_second_leg_active
export w_second_leg_active
export early_bullish_entry
export early_bearish_entry
export pattern_name
export ema_13

// Export candlestick pattern detection
export bullish_patterns
export bearish_patterns
export indecision_patterns
export any_pattern_active

// Export specific pattern signals
export hammer
export shooting_star
export railroad_bull
export railroad_bear
export bullish_engulfing
export bearish_engulfing
export morning_star
export evening_star
export doji
export cord_of_wood
// ============================================================================
// MERGED FROM: BTMM_Market_Maker_Phases
// ============================================================================

// ═══════════════════════════════════════════════════════════════════════════════════
// 📊 BTMM PERFORMANCE TRACKER - SCRIPT 7 OF 10
// Steve Mauro's Beat The Market Maker Methodology
// Focus: Trade Performance Analytics, Win Rate Tracking, R:R Analysis, Strategy Stats
// ═══════════════════════════════════════════════════════════════════════════════════

import TradingView/ta/7 as ta

// === PERFORMANCE TRACKING CONFIGURATION ===
perf_group = "📊 Performance Tracking"
track_signals = input.bool(true, "Track Trading Signals", group=perf_group)
initial_balance = input.float(10000.0, "Initial Account Balance", minval=1000.0, group=perf_group)
risk_per_trade = input.float(1.0, "Risk Per Trade (%)", minval=0.1, maxval=5.0, group=perf_group)
show_performance_table = input.bool(true, "Show Performance Table", group=perf_group)
reset_stats = input.bool(false, "Reset Statistics", group=perf_group)

// === SIGNAL DETECTION SETTINGS ===
signal_group = "🎯 Signal Detection"
signal_source = input.string("AUTO", "Signal Source", options=["AUTO", "MANUAL", "EXTERNAL"], group=signal_group)
manual_long_signal = input.bool(false, "Manual Long Signal", group=signal_group)
manual_short_signal = input.bool(false, "Manual Short Signal", group=signal_group)
auto_signal_sensitivity = input.float(1.0, "Auto Signal Sensitivity", minval=0.5, maxval=2.0, group=signal_group)

// === RISK MANAGEMENT ===
risk_group = "🛡️ Risk Management"
stop_loss_atr_mult = input.float(2.0, "Stop Loss ATR Multiplier", minval=0.5, maxval=5.0, group=risk_group)
take_profit_rr = input.float(2.0, "Take Profit R:R Ratio", minval=1.0, maxval=5.0, group=risk_group)
max_open_trades = input.int(3, "Max Concurrent Trades", minval=1, maxval=10, group=risk_group)
enable_trailing_stop = input.bool(true, "Enable Trailing Stop", group=risk_group)

// === VISUAL SETTINGS ===
visual_group = "🎨 Visual Configuration"
show_equity_curve = input.bool(true, "Show Equity Curve", group=visual_group)
show_drawdown = input.bool(true, "Show Drawdown", group=visual_group)
show_trade_markers = input.bool(true, "Show Trade Entry/Exit Markers", group=visual_group)
equity_line_color = input.color(color.blue, "Equity Line Color", group=visual_group)
drawdown_color = input.color(color.red, "Drawdown Color", group=visual_group)

// ═══════════════════════════════════════════════════════════════════════════════════
// 📊 PERFORMANCE VARIABLES
// ═══════════════════════════════════════════════════════════════════════════════════

// Trading Statistics
var int total_trades = 0
var int winning_trades = 0
var int losing_trades = 0
var float total_profit = 0.0
var float total_loss = 0.0
var float current_balance = initial_balance
var float peak_balance = initial_balance
var float max_drawdown = 0.0
var float max_consecutive_wins = 0.0
var float max_consecutive_losses = 0.0
var float current_consecutive_wins = 0.0
var float current_consecutive_losses = 0.0

// Trade Tracking Arrays
var array<float> trade_returns = array.new<float>()
var array<float> equity_curve = array.new<float>()
var array<float> drawdown_curve = array.new<float>()

// Current Trade State
var bool in_long_trade = false
var bool in_short_trade = false
var float trade_entry_price = na
var float trade_stop_loss = na
var float trade_take_profit = na
var int trade_entry_bar = na
var float trade_risk_amount = 0.0

// Reset statistics if requested
if reset_stats and not reset_stats[1]
    total_trades := 0
    winning_trades := 0
    losing_trades := 0
    total_profit := 0.0
    total_loss := 0.0
    current_balance := initial_balance
    peak_balance := initial_balance
    max_drawdown := 0.0
    max_consecutive_wins := 0.0
    max_consecutive_losses := 0.0
    current_consecutive_wins := 0.0
    current_consecutive_losses := 0.0
    array.clear(trade_returns)
    array.clear(equity_curve)
    array.clear(drawdown_curve)

// ═══════════════════════════════════════════════════════════════════════════════════
// 🎯 SIGNAL DETECTION LOGIC
// ═══════════════════════════════════════════════════════════════════════════════════

// ATR for stop loss calculation
atr_value = ta.atr(14)

// EMA for trend detection
ema_13 = ta.ema(close, 13)
ema_50 = ta.ema(close, 50)

// Auto signal generation based on BTMM principles
generate_auto_signals() =>
    var bool long_signal = false
    var bool short_signal = false

    // EMA alignment check
    ema_bullish = ema_13 > ema_50
    ema_bearish = ema_13 < ema_50

    // Price action signals
    bullish_candle = close > open and close > ema_13
    bearish_candle = close < open and close < ema_13

    // Volume confirmation
    avg_volume = ta.sma(volume, 20)
    volume_spike = volume > avg_volume * 1.2

    // Generate signals with confluence
    if ema_bullish and bullish_candle and volume_spike and not in_long_trade
        long_signal := true

    if ema_bearish and bearish_candle and volume_spike and not in_short_trade
        short_signal := true

    [long_signal, short_signal]

// Signal detection based on source
[auto_long, auto_short] = generate_auto_signals()

long_signal = switch signal_source
    "AUTO" => auto_long
    "MANUAL" => manual_long_signal and not manual_long_signal[1]
    "EXTERNAL" => false  // Would integrate with external signals
    => auto_long

short_signal = switch signal_source
    "AUTO" => auto_short
    "MANUAL" => manual_short_signal and not manual_short_signal[1]
    "EXTERNAL" => false  // Would integrate with external signals
    => auto_short

// ═══════════════════════════════════════════════════════════════════════════════════
// 💼 TRADE MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════════════

// Enter Long Trade
if long_signal and not in_long_trade
    in_long_trade := true
    trade_entry_price := close
    trade_stop_loss := close - (atr_value * stop_loss_atr_mult)
    trade_take_profit := close + ((close - trade_stop_loss) * take_profit_rr)
    trade_entry_bar := bar_index
    trade_risk_amount := current_balance * (risk_per_trade / 100)

// Enter Short Trade
if short_signal and not in_short_trade
    in_short_trade := true
    trade_entry_price := close
    trade_stop_loss := close + (atr_value * stop_loss_atr_mult)
    trade_take_profit := close - ((trade_stop_loss - close) * take_profit_rr)
    trade_entry_bar := bar_index
    trade_risk_amount := current_balance * (risk_per_trade / 100)

// Exit Long Trade
if in_long_trade
    long_tp_hit = high >= trade_take_profit
    long_sl_hit = low <= trade_stop_loss

    if long_tp_hit or long_sl_hit
        // Calculate trade result
        exit_price = long_tp_hit ? trade_take_profit : trade_stop_loss
        trade_return = long_tp_hit ? trade_risk_amount * take_profit_rr : -trade_risk_amount

        // Update statistics
        total_trades += 1
        if trade_return > 0
            winning_trades += 1
            total_profit += trade_return
            current_consecutive_wins += 1
            current_consecutive_losses := 0
            max_consecutive_wins := math.max(max_consecutive_wins, current_consecutive_wins)
        else
            losing_trades += 1
            total_loss += math.abs(trade_return)
            current_consecutive_losses += 1
            current_consecutive_wins := 0
            max_consecutive_losses := math.max(max_consecutive_losses, current_consecutive_losses)

        // Update balance and equity
        current_balance += trade_return
        array.push(trade_returns, trade_return)
        array.push(equity_curve, current_balance)

        // Calculate drawdown
        peak_balance := math.max(peak_balance, current_balance)
        current_drawdown = (peak_balance - current_balance) / peak_balance * 100
        max_drawdown := math.max(max_drawdown, current_drawdown)
        array.push(drawdown_curve, current_drawdown)

        in_long_trade := false

// Exit Short Trade
if in_short_trade
    short_tp_hit = low <= trade_take_profit
    short_sl_hit = high >= trade_stop_loss

    if short_tp_hit or short_sl_hit
        // Calculate trade result
        exit_price = short_tp_hit ? trade_take_profit : trade_stop_loss
        trade_return = short_tp_hit ? trade_risk_amount * take_profit_rr : -trade_risk_amount

        // Update statistics
        total_trades += 1
        if trade_return > 0
            winning_trades += 1
            total_profit += trade_return
            current_consecutive_wins += 1
            current_consecutive_losses := 0
            max_consecutive_wins := math.max(max_consecutive_wins, current_consecutive_wins)
        else
            losing_trades += 1
            total_loss += math.abs(trade_return)
            current_consecutive_losses += 1
            current_consecutive_wins := 0
            max_consecutive_losses := math.max(max_consecutive_losses, current_consecutive_losses)

        # Update balance and equity
        current_balance += trade_return
        array.push(trade_returns, trade_return)
        array.push(equity_curve, current_balance)

        # Calculate drawdown
        peak_balance := math.max(peak_balance, current_balance)
        current_drawdown = (peak_balance - current_balance) / peak_balance * 100
        max_drawdown := math.max(max_drawdown, current_drawdown)
        array.push(drawdown_curve, current_drawdown)

        in_short_trade := false

// ═══════════════════════════════════════════════════════════════════════════════════
// 📊 PERFORMANCE CALCULATIONS
// ═══════════════════════════════════════════════════════════════════════════════════

// Calculate key performance metrics
win_rate = total_trades > 0 ? (winning_trades / total_trades) * 100 : 0
avg_win = winning_trades > 0 ? total_profit / winning_trades : 0
avg_loss = losing_trades > 0 ? total_loss / losing_trades : 0
profit_factor = total_loss > 0 ? total_profit / total_loss : na
total_return = ((current_balance - initial_balance) / initial_balance) * 100
sharpe_ratio = array.size(trade_returns) > 0 ? array.avg(trade_returns) / array.stdev(trade_returns) : na

// Risk-adjusted returns
calmar_ratio = max_drawdown > 0 ? total_return / max_drawdown : na
recovery_factor = total_loss > 0 ? (current_balance - initial_balance) / total_loss : na

// ═══════════════════════════════════════════════════════════════════════════════════
// 🎨 VISUAL DISPLAY
// ═══════════════════════════════════════════════════════════════════════════════════

// Plot Equity Curve
equity_normalized = show_equity_curve ? (current_balance / initial_balance - 1) * 100 : na
plot(equity_normalized, "Equity Curve (%)", color=equity_line_color, linewidth=2)

// Plot Drawdown
current_dd = array.size(drawdown_curve) > 0 ? array.get(drawdown_curve, array.size(drawdown_curve) - 1) : 0
plot(show_drawdown ? -current_dd : na, "Drawdown (%)", color=drawdown_color, linewidth=2)

// Zero line
hline(0, "Zero Line", color=color.gray, linestyle=hline.style_dashed)

// Trade Entry/Exit Markers
if show_trade_markers
    if long_signal
        label.new(bar_index, 0, "🔺 LONG", style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)

    if short_signal
        label.new(bar_index, 0, "🔻 SHORT", style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

// ═══════════════════════════════════════════════════════════════════════════════════
// 📊 PERFORMANCE TABLES
// ═══════════════════════════════════════════════════════════════════════════════════

if show_performance_table and barstate.islast
    // Main Performance Table
    var table perf_table = table.new(position.bottom_left, 3, 10, bgcolor=color.new(color.white, 10), border_width=2)

    // Header
    table.cell(perf_table, 0, 0, "BTMM PERFORMANCE", bgcolor=color.navy, text_color=color.white, text_size=size.normal)
    table.cell(perf_table, 1, 0, "VALUE", bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(perf_table, 2, 0, "RATING", bgcolor=color.gray, text_color=color.white, text_size=size.normal)

    // Total Trades
    table.cell(perf_table, 0, 1, "Total Trades", bgcolor=color.blue, text_color=color.white)
    table.cell(perf_table, 1, 1, str.tostring(total_trades), bgcolor=color.new(color.blue, 70), text_color=color.white)
    trade_rating = total_trades >= 30 ? "✅ SUFFICIENT" : total_trades >= 10 ? "⚠️ LIMITED" : "❌ TOO FEW"
    trade_color = total_trades >= 30 ? color.new(color.green, 70) : total_trades >= 10 ? color.new(color.orange, 70) : color.new(color.red, 70)
    table.cell(perf_table, 2, 1, trade_rating, bgcolor=trade_color, text_color=color.white)

    // Win Rate
    table.cell(perf_table, 0, 2, "Win Rate", bgcolor=color.green, text_color=color.white)
    table.cell(perf_table, 1, 2, str.tostring(win_rate, "#.#") + "%", bgcolor=color.new(color.green, 70), text_color=color.white)
    wr_rating = win_rate >= 60 ? "🔥 EXCELLENT" : win_rate >= 50 ? "✅ GOOD" : win_rate >= 40 ? "⚠️ AVERAGE" : "❌ POOR"
    wr_color = win_rate >= 60 ? color.new(color.green, 50) : win_rate >= 50 ? color.new(color.green, 70) : win_rate >= 40 ? color.new(color.orange, 70) : color.new(color.red, 70)
    table.cell(perf_table, 2, 2, wr_rating, bgcolor=wr_color, text_color=color.white)

    // Profit Factor
    table.cell(perf_table, 0, 3, "Profit Factor", bgcolor=color.purple, text_color=color.white)
    pf_text = not na(profit_factor) ? str.tostring(profit_factor, "#.##") : "N/A"
    table.cell(perf_table, 1, 3, pf_text, bgcolor=color.new(color.purple, 70), text_color=color.white)
    pf_rating = not na(profit_factor) ? (profit_factor >= 2.0 ? "🔥 EXCELLENT" : profit_factor >= 1.5 ? "✅ GOOD" : profit_factor >= 1.0 ? "📊 BREAK-EVEN" : "❌ LOSING") : "❓ N/A"
    pf_color = not na(profit_factor) ? (profit_factor >= 2.0 ? color.new(color.green, 50) : profit_factor >= 1.5 ? color.new(color.green, 70) : profit_factor >= 1.0 ? color.new(color.orange, 70) : color.new(color.red, 70)) : color.new(color.gray, 70)
    table.cell(perf_table, 2, 3, pf_rating, bgcolor=pf_color, text_color=color.white)

    // Total Return
    table.cell(perf_table, 0, 4, "Total Return", bgcolor=color.orange, text_color=color.white)
    table.cell(perf_table, 1, 4, str.tostring(total_return, "#.#") + "%", bgcolor=color.new(color.orange, 70), text_color=color.white)
    return_rating = total_return >= 20 ? "🔥 EXCELLENT" : total_return >= 10 ? "✅ GOOD" : total_return >= 0 ? "📊 POSITIVE" : "❌ NEGATIVE"
    return_color = total_return >= 20 ? color.new(color.green, 50) : total_return >= 10 ? color.new(color.green, 70) : total_return >= 0 ? color.new(color.orange, 70) : color.new(color.red, 70)
    table.cell(perf_table, 2, 4, return_rating, bgcolor=return_color, text_color=color.white)

    // Max Drawdown
    table.cell(perf_table, 0, 5, "Max Drawdown", bgcolor=color.red, text_color=color.white)
    table.cell(perf_table, 1, 5, str.tostring(max_drawdown, "#.#") + "%", bgcolor=color.new(color.red, 70), text_color=color.white)
    dd_rating = max_drawdown <= 5 ? "✅ EXCELLENT" : max_drawdown <= 10 ? "📊 GOOD" : max_drawdown <= 20 ? "⚠️ MODERATE" : "❌ HIGH"
    dd_color = max_drawdown <= 5 ? color.new(color.green, 70) : max_drawdown <= 10 ? color.new(color.orange, 70) : max_drawdown <= 20 ? color.new(color.orange, 50) : color.new(color.red, 50)
    table.cell(perf_table, 2, 5, dd_rating, bgcolor=dd_color, text_color=color.white)

    // Current Balance
    table.cell(perf_table, 0, 6, "Current Balance", bgcolor=color.teal, text_color=color.white)
    table.cell(perf_table, 1, 6, "$" + str.tostring(current_balance, "#,###"), bgcolor=color.new(color.teal, 70), text_color=color.white)
    balance_status = current_balance > initial_balance ? "📈 PROFIT" : current_balance == initial_balance ? "📊 BREAK-EVEN" : "📉 LOSS"
    balance_color = current_balance > initial_balance ? color.new(color.green, 70) : current_balance == initial_balance ? color.new(color.gray, 70) : color.new(color.red, 70)
    table.cell(perf_table, 2, 6, balance_status, bgcolor=balance_color, text_color=color.white)

    // Sharpe Ratio
    table.cell(perf_table, 0, 7, "Sharpe Ratio", bgcolor=color.yellow, text_color=color.black)
    sharpe_text = not na(sharpe_ratio) ? str.tostring(sharpe_ratio, "#.##") : "N/A"
    table.cell(perf_table, 1, 7, sharpe_text, bgcolor=color.new(color.yellow, 70), text_color=color.black)
    sharpe_rating = not na(sharpe_ratio) ? (sharpe_ratio >= 2.0 ? "🔥 EXCELLENT" : sharpe_ratio >= 1.0 ? "✅ GOOD" : sharpe_ratio >= 0 ? "📊 POSITIVE" : "❌ POOR") : "❓ N/A"
    table.cell(perf_table, 2, 7, sharpe_rating, bgcolor=color.new(color.yellow, 70), text_color=color.black)

    // Consecutive Wins/Losses
    table.cell(perf_table, 0, 8, "Max Consec Wins", bgcolor=color.lime, text_color=color.black)
    table.cell(perf_table, 1, 8, str.tostring(max_consecutive_wins), bgcolor=color.new(color.lime, 70), text_color=color.black)
    win_streak_rating = max_consecutive_wins >= 5 ? "🔥 STRONG" : max_consecutive_wins >= 3 ? "✅ GOOD" : "📊 NORMAL"
    table.cell(perf_table, 2, 8, win_streak_rating, bgcolor=color.new(color.lime, 70), text_color=color.black)

    table.cell(perf_table, 0, 9, "Max Consec Losses", bgcolor=color.maroon, text_color=color.white)
    table.cell(perf_table, 1, 9, str.tostring(max_consecutive_losses), bgcolor=color.new(color.maroon, 70), text_color=color.white)
    loss_streak_rating = max_consecutive_losses <= 2 ? "✅ EXCELLENT" : max_consecutive_losses <= 4 ? "📊 ACCEPTABLE" : "⚠️ CONCERNING"
    loss_streak_color = max_consecutive_losses <= 2 ? color.new(color.green, 70) : max_consecutive_losses <= 4 ? color.new(color.orange, 70) : color.new(color.red, 50)
    table.cell(perf_table, 2, 9, loss_streak_rating, bgcolor=loss_streak_color, text_color=color.white)

// Strategy Summary Table
if show_performance_table and barstate.islast
    var table summary_table = table.new(position.top_right, 2, 6, bgcolor=color.new(color.white, 10), border_width=2)

    // Header
    table.cell(summary_table, 0, 0, "STRATEGY SUMMARY", bgcolor=color.navy, text_color=color.white, text_size=size.normal)
    table.cell(summary_table, 1, 0, "STATUS", bgcolor=color.gray, text_color=color.white, text_size=size.normal)

    // Overall Rating
    overall_score = 0
    if win_rate >= 50: overall_score += 1
    if not na(profit_factor) and profit_factor >= 1.5: overall_score += 1
    if max_drawdown <= 10: overall_score += 1
    if total_return >= 10: overall_score += 1
    if total_trades >= 20: overall_score += 1

    overall_rating = overall_score >= 4 ? "🔥 EXCELLENT" : overall_score >= 3 ? "✅ GOOD" : overall_score >= 2 ? "📊 AVERAGE" : "❌ NEEDS WORK"
    overall_color = overall_score >= 4 ? color.new(color.green, 50) : overall_score >= 3 ? color.new(color.green, 70) : overall_score >= 2 ? color.new(color.orange, 70) : color.new(color.red, 70)
    table.cell(summary_table, 0, 1, "Overall Rating", bgcolor=color.purple, text_color=color.white)
    table.cell(summary_table, 1, 1, overall_rating, bgcolor=overall_color, text_color=color.white)

    // Current Trade Status
    trade_status = in_long_trade ? "🔺 LONG ACTIVE" : in_short_trade ? "🔻 SHORT ACTIVE" : "❌ NO TRADE"
    trade_status_color = in_long_trade or in_short_trade ? color.new(color.blue, 70) : color.new(color.gray, 70)
    table.cell(summary_table, 0, 2, "Trade Status", bgcolor=color.blue, text_color=color.white)
    table.cell(summary_table, 1, 2, trade_status, bgcolor=trade_status_color, text_color=color.white)

    // Strategy Health
    health_score = 0
    if win_rate >= 45: health_score += 1
    if max_drawdown <= 15: health_score += 1
    if not na(profit_factor) and profit_factor >= 1.2: health_score += 1

    health_status = health_score >= 3 ? "💪 HEALTHY" : health_score >= 2 ? "📊 STABLE" : "⚠️ NEEDS ATTENTION"
    health_color = health_score >= 3 ? color.new(color.green, 70) : health_score >= 2 ? color.new(color.orange, 70) : color.new(color.red, 70)
    table.cell(summary_table, 0, 3, "Strategy Health", bgcolor=color.orange, text_color=color.white)
    table.cell(summary_table, 1, 3, health_status, bgcolor=health_color, text_color=color.white)

    // Risk Level
    risk_level = max_drawdown <= 5 ? "🟢 LOW" : max_drawdown <= 15 ? "🟡 MODERATE" : "🔴 HIGH"
    risk_color = max_drawdown <= 5 ? color.new(color.green, 70) : max_drawdown <= 15 ? color.new(color.orange, 70) : color.new(color.red, 70)
    table.cell(summary_table, 0, 4, "Risk Level", bgcolor=color.red, text_color=color.white)
    table.cell(summary_table, 1, 4, risk_level, bgcolor=risk_color, text_color=color.white)

    // Recommendation
    recommendation = overall_score >= 4 ? "🚀 CONTINUE" : overall_score >= 2 ? "🔧 OPTIMIZE" : "🛑 REVISE"
    rec_color = overall_score >= 4 ? color.new(color.green, 50) : overall_score >= 2 ? color.new(color.orange, 60) : color.new(color.red, 60)
    table.cell(summary_table, 0, 5, "Recommendation", bgcolor=color.navy, text_color=color.white)
    table.cell(summary_table, 1, 5, recommendation, bgcolor=rec_color, text_color=color.white)

// ═══════════════════════════════════════════════════════════════════════════════════
// 📤 EXPORT FOR INTEGRATION WITH OTHER SCRIPTS
// ═══════════════════════════════════════════════════════════════════════════════════

export win_rate
export profit_factor
export total_return
export max_drawdown
export current_balance
export total_trades
export in_long_trade
export in_short_trade
// ============================================================================
// MERGED FROM: BTMM_Custom_Candles
// ============================================================================

// =============================================================================
// BTMM ENHANCED FOUNDATION LIBRARY - Script 9/10
// =============================================================================
// @description Enhanced core infrastructure library for all BTMM trading system components
// @purpose Provides session detection, 3-day cycle tracking, timeframe classification,
//          current-day filters, Asian-range helpers, EMA-stack analysis, volume/market
//          structure analytics, Fibonacci utilities, and risk-management calculations
// @method Centralized library functions imported by all BTMM scripts for consistency
// @author BTMM Development Team - Enhanced for Replit Platform
// @version 3.0 - Enhanced with Replit platform integration and performance optimizations
// @date July 2025
// =============================================================================

library("BTMMEnhancedFoundation", overlay=false)

// ═══════════════════════════════════════════════════════════════════════════════════
// 🎯 BTMM ENHANCED FOUNDATION LIBRARY - Core Infrastructure
// Enhanced version of your original BTMMFoundation.pine with additional features
// for the comprehensive 10-script integrated system
// ═══════════════════════════════════════════════════════════════════════════════════

import TradingView/ta/7 as ta

// ═══════════════════════════════════════════════════════════════════════════════════
// 📊 SESSION DETECTION & 3-DAY CYCLE (Enhanced)
// ═══════════════════════════════════════════════════════════════════════════════════

export session_and_cycle_enhanced() =>
    // Enhanced session time blocks with additional market maker periods
    asian = time(timeframe.period, "1700-0500", "America/New_York")
    london_pre = time(timeframe.period, "0200-0330", "America/New_York")  // Pre-London accumulation
    london = time(timeframe.period, "0330-0900", "America/New_York")      // London manipulation
    london_ny_overlap = time(timeframe.period, "0830-1100", "America/New_York")  // High volatility overlap
    ny = time(timeframe.period, "0930-1700", "America/New_York")          // NY distribution
    ny_close = time(timeframe.period, "1500-1700", "America/New_York")    // NY close positioning

    // Determine current session with priority hierarchy
    current_session = asian ? "ASIAN" :
                     london_pre ? "LONDON_PRE" :
                     london_ny_overlap ? "LONDON_NY_OVERLAP" :
                     london ? "LONDON" :
                     ny ? "NY" :
                     ny_close ? "NY_CLOSE" : "OFF_HOURS"

    // Enhanced 3-day cycle with Steve Mauro's institutional flow
    var int cycle_day = 1
    var int cycle_phase = 1  // 1=Accumulation, 2=Manipulation, 3=Distribution
    var int ref_start = 0

    // Reset at Monday London open
    reset_point = dayofweek == dayofweek.monday and london and not london[1]
    if reset_point
        cycle_day := 1
        cycle_phase := 1
        ref_start := time
    else
        elapsed_days = math.floor((time - ref_start) / (24 * 60 * 60 * 1000))
        if elapsed_days >= 0 and elapsed_days < 1
            cycle_day := 1
            cycle_phase := current_session == "ASIAN" ? 1 : current_session == "LONDON" or current_session == "LONDON_PRE" ? 2 : 3
        else if elapsed_days >= 1 and elapsed_days < 2
            cycle_day := 2
            cycle_phase := current_session == "ASIAN" ? 1 : current_session == "LONDON" or current_session == "LONDON_PRE" ? 2 : 3
        else if elapsed_days >= 2 and elapsed_days < 3
            cycle_day := 3
            cycle_phase := current_session == "ASIAN" ? 1 : current_session == "LONDON" or current_session == "LONDON_PRE" ? 2 : 3

    // Market maker activity level
    mm_activity_level = london_ny_overlap ? "HIGH" : (london or ny) ? "MEDIUM" : asian ? "LOW" : "MINIMAL"

    [asian, london, ny, london_ny_overlap, current_session, cycle_day, cycle_phase, mm_activity_level]

export is_prime_trading_session() =>
    [_, london, ny, overlap, _, _, _, _] = session_and_cycle_enhanced()
    london or ny or overlap

export get_session_volatility_factor() =>
    [_, london, ny, overlap, session, _, _, _] = session_and_cycle_enhanced()
    overlap ? 1.5 : (london or ny) ? 1.2 : session == "ASIAN" ? 0.8 : 0.5

// ═══════════════════════════════════════════════════════════════════════════════════
// ⏰ ENHANCED TIMEFRAME CLASSIFICATION
// ═══════════════════════════════════════════════════════════════════════════════════

export timeframe_classification_enhanced() =>
    tfm = timeframe.in_seconds() / 60

    // Steve Mauro timeframe hierarchy
    is_htf_analysis = tfm >= 240 and tfm <= 1440     // 4H-1D (Higher timeframe bias)
    is_intermediate = tfm >= 60 and tfm <= 240       // 1H-4H (Trend analysis)
    is_execution = tfm >= 15 and tfm <= 60           // 15M-1H (Entry execution)
    is_scalping = tfm >= 1 and tfm <= 15             // 1M-15M (Scalping/early entry)

    // BTMM optimal timeframes
    is_bias_tf = tfm >= 15                            // 15M+ for bias determination
    is_ote_tf = tfm >= 5 and tfm <= 60              // 5M-1H for OTE zones
    is_pattern_tf = tfm >= 15 and tfm <= 240        // 15M-4H for pattern recognition

    // Timeframe quality score (higher is better for BTMM)
    tf_quality_score = is_bias_tf ? (is_execution ? 10 : is_intermediate ? 8 : is_htf_analysis ? 6 : 4) : 2

    [is_htf_analysis, is_intermediate, is_execution, is_scalping, is_bias_tf, is_ote_tf, is_pattern_tf, tf_quality_score]

export get_optimal_timeframe_for_analysis(analysis_type) =>
    [htf, intermediate, execution, scalping, bias_tf, ote_tf, pattern_tf, quality] = timeframe_classification_enhanced()

    switch analysis_type
        "BIAS" => bias_tf
        "OTE" => ote_tf
        "PATTERNS" => pattern_tf
        "EXECUTION" => execution
        "SCALPING" => scalping
        => execution

// ═══════════════════════════════════════════════════════════════════════════════════
// 🌏 ENHANCED ASIAN RANGE ANALYSIS
// ═══════════════════════════════════════════════════════════════════════════════════

export asian_range_enhanced() =>
    [asian, _, _, _, _, _, _, _] = session_and_cycle_enhanced()

    var float asian_high = na
    var float asian_low = na
    var float asian_midpoint = na
    var float asian_range_size = na
    var bool asian_range_valid = false
    var int asian_range_bars = 0

    // Reset at Asian session start
    if asian and not asian[1]
        asian_high := high
        asian_low := low
        asian_range_bars := 0
        asian_range_valid := false

    // Update during Asian session
    if asian
        asian_high := math.max(asian_high, high)
        asian_low := math.min(asian_low, low)
        asian_range_bars += 1

    // Finalize at Asian session end
    if not asian and asian[1] and not na(asian_high) and not na(asian_low)
        asian_range_size := asian_high - asian_low
        asian_midpoint := (asian_high + asian_low) / 2

        // Validate range quality (Steve Mauro criteria)
        pip_size = syminfo.mintick * 10
        range_pips = asian_range_size / pip_size
        asian_range_valid := range_pips >= 20 and range_pips <= 100 and asian_range_bars >= 10

    // Calculate range extensions
    range_extension_up = not na(asian_high) and not na(asian_range_size) ? asian_high + (asian_range_size * 0.5) : na
    range_extension_down = not na(asian_low) and not na(asian_range_size) ? asian_low - (asian_range_size * 0.5) : na

    // Range breakout detection
    bullish_breakout = not na(asian_high) and close > asian_high
    bearish_breakout = not na(asian_low) and close < asian_low

    [asian_high, asian_low, asian_midpoint, asian_range_size, asian_range_valid,
     range_extension_up, range_extension_down, bullish_breakout, bearish_breakout]

export asian_range_quality_score() =>
    [_, _, _, range_size, valid, _, _, _, _] = asian_range_enhanced()

    if not na(range_size) and valid
        pip_size = syminfo.mintick * 10
        range_pips = range_size / pip_size

        // Score based on optimal range criteria
        if range_pips >= 40 and range_pips <= 60
            10  // Perfect range
        else if range_pips >= 30 and range_pips <= 80
            8   // Good range
        else if range_pips >= 20 and range_pips <= 100
            6   // Acceptable range
        else
            3   // Suboptimal range
    else
        0   // Invalid range

// ═══════════════════════════════════════════════════════════════════════════════════
// 📊 ENHANCED EMA STACK ANALYSIS (Steve Mauro Food System)
// ═══════════════════════════════════════════════════════════════════════════════════

export ema_stack_analysis_enhanced(ema_5, ema_13, ema_50, ema_200, ema_800) =>
    // Perfect stack detection
    perfect_bull_stack = ema_5 > ema_13 and ema_13 > ema_50 and ema_50 > ema_200 and ema_200 > ema_800
    perfect_bear_stack = ema_5 < ema_13 and ema_13 < ema_50 and ema_50 < ema_200 and ema_200 < ema_800

    // Partial stack analysis
    short_term_bullish = ema_5 > ema_13 and ema_13 > ema_50
    medium_term_bullish = ema_50 > ema_200
    long_term_bullish = ema_200 > ema_800

    short_term_bearish = ema_5 < ema_13 and ema_13 < ema_50
    medium_term_bearish = ema_50 < ema_200
    long_term_bearish = ema_200 < ema_800

    // Stack strength calculation (0-10 scale)
    stack_strength = 0.0
    if perfect_bull_stack or perfect_bear_stack
        stack_strength := 10.0
    else
        strength_components = 0
        if short_term_bullish or short_term_bearish
            strength_components += 3
        if medium_term_bullish or medium_term_bearish
            strength_components += 4
        if long_term_bullish or long_term_bearish
            strength_components += 3
        stack_strength := strength_components

    // EMA separation analysis (confluence factor)
    ema_separation_score = 0.0
    if not na(ema_5) and not na(ema_800)
        total_range = math.abs(ema_5 - ema_800)
        avg_price = (ema_5 + ema_800) / 2
        separation_percentage = (total_range / avg_price) * 100

        ema_separation_score := separation_percentage >= 2.0 ? 10 :
                               separation_percentage >= 1.0 ? 7 :
                               separation_percentage >= 0.5 ? 5 : 3

    // Overall stack health
    stack_health = "POOR"
    if stack_strength >= 8
        stack_health := "EXCELLENT"
    else if stack_strength >= 6
        stack_health := "GOOD"
    else if stack_strength >= 4
        stack_health := "FAIR"

    [perfect_bull_stack, perfect_bear_stack, stack_strength, ema_separation_score, stack_health,
     short_term_bullish, medium_term_bullish, long_term_bullish,
     short_term_bearish, medium_term_bearish, long_term_bearish]

export calculate_btmm_bias_score_enhanced(price, ema_5, ema_13, ema_50, ema_200, ema_800) =>
    // Enhanced bias scoring with Steve Mauro methodology
    score = 0.0

    // Price position relative to each EMA (base score)
    score += price > ema_5 ? 1.0 : -1.0
    score += price > ema_13 ? 1.5 : -1.5    // Ketchup line gets extra weight
    score += price > ema_50 ? 1.0 : -1.0
    score += price > ema_200 ? 1.5 : -1.5   // Mayo line gets extra weight
    score += price > ema_800 ? 1.0 : -1.0

    // Stack alignment bonus
    [perfect_bull, perfect_bear, stack_strength, _, _, _, _, _, _, _, _] = ema_stack_analysis_enhanced(ema_5, ema_13, ema_50, ema_200, ema_800)

    if perfect_bull
        score += 3.0
    else if perfect_bear
        score -= 3.0
    else
        score += (stack_strength / 10) * 2.0 * (score > 0 ? 1 : -1)

    # Momentum factor
    ema_13_momentum = ta.change(ema_13, 3)
    if not na(ema_13_momentum)
        momentum_factor = ema_13_momentum > 0 ? 0.5 : ema_13_momentum < 0 ? -0.5 : 0
        score += momentum_factor

    # Cap the score between -10 and +10
    math.max(-10, math.min(10, score))

// ═══════════════════════════════════════════════════════════════════════════════════
// 📈 ENHANCED VOLUME & MARKET STRUCTURE ANALYSIS
// ═══════════════════════════════════════════════════════════════════════════════════

export volume_analysis_enhanced() =>
    // Enhanced volume analysis with institutional flow detection
    avg_volume_20 = ta.sma(volume, 20)
    avg_volume_50 = ta.sma(volume, 50)

    volume_ratio_20 = volume / avg_volume_20
    volume_ratio_50 = volume / avg_volume_50

    # Volume classification
    volume_spike = volume_ratio_20 >= 2.0
    volume_surge = volume_ratio_20 >= 1.5 and volume_ratio_20 < 2.0
    volume_normal = volume_ratio_20 >= 0.8 and volume_ratio_20 < 1.5
    volume_low = volume_ratio_20 < 0.8

    # Institutional volume detection
    institutional_volume = volume_ratio_50 >= 3.0 and (close > open) != (close[1] > open[1])

    # Volume trend analysis
    volume_trend_bullish = ta.sma(volume, 5) > ta.sma(volume, 20)
    volume_trend_bearish = ta.sma(volume, 5) < ta.sma(volume, 20)

    # Volume-price relationship
    volume_price_alignment = (volume_ratio_20 >= 1.2 and math.abs(ta.change(close)) >= ta.atr(14) * 0.5)

    [volume_spike, volume_surge, volume_normal, volume_low, institutional_volume,
     volume_trend_bullish, volume_trend_bearish, volume_price_alignment, volume_ratio_20]

export market_structure_analysis() =>
    # Enhanced market structure with Steve Mauro concepts
    atr_current = ta.atr(14)
    atr_slow = ta.sma(atr_current, 20)

    volatility_ratio = atr_current / atr_slow
    volatility_state = volatility_ratio >= 1.5 ? "HIGH" : volatility_ratio >= 1.2 ? "ELEVATED" : volatility_ratio <= 0.8 ? "LOW" : "NORMAL"

    # Market maker signature detection
    inside_bar = high <= high[1] and low >= low[1]
    outside_bar = high > high[1] and low < low[1]

    # Liquidity levels (simplified)
    swing_high_20 = ta.highest(high, 20)
    swing_low_20 = ta.lowest(low, 20)

    near_resistance = close >= swing_high_20 * 0.995
    near_support = close <= swing_low_20 * 1.005

    # Market phase detection
    trending = math.abs(ta.sma(close, 20) - ta.sma(close, 50)) >= atr_current
    ranging = not trending

    [volatility_state, inside_bar, outside_bar, near_resistance, near_support, trending, ranging, volatility_ratio]

// ═══════════════════════════════════════════════════════════════════════════════════
// 🔢 ENHANCED FIBONACCI & OTE UTILITIES
// ═══════════════════════════════════════════════════════════════════════════════════

export fibonacci_ote_analysis(swing_high, swing_low, trend_direction) =>
    if na(swing_high) or na(swing_low) or swing_high == swing_low
        [na, na, na, na, na, false, false]
    else
        range_size = swing_high - swing_low

        # Key Fibonacci levels
        fib_618 = trend_direction == 1 ? swing_high - (range_size * 0.618) : swing_low + (range_size * 0.618)
        fib_705 = trend_direction == 1 ? swing_high - (range_size * 0.705) : swing_low + (range_size * 0.705)
        fib_786 = trend_direction == 1 ? swing_high - (range_size * 0.786) : swing_low + (range_size * 0.786)
        fib_79 = trend_direction == 1 ? swing_high - (range_size * 0.79) : swing_low + (range_size * 0.79)
        fib_50 = swing_low + (range_size * 0.5)

        # OTE zone detection (70.5% to 79% retracement)
        ote_upper = trend_direction == 1 ? fib_705 : fib_79
        ote_lower = trend_direction == 1 ? fib_79 : fib_705

        in_ote_zone = close <= ote_upper and close >= ote_lower
        ote_zone_quality = in_ote_zone and math.abs(close - ((ote_upper + ote_lower) / 2)) <= (ote_upper - ote_lower) * 0.25

        [fib_618, fib_705, fib_786, fib_79, fib_50, in_ote_zone, ote_zone_quality]

export premium_discount_analysis(current_price, range_high, range_low) =>
    if na(range_high) or na(range_low) or range_high == range_low
        [na, false, false, false]
    else
        range_position = (current_price - range_low) / (range_high - range_low)

        in_premium = range_position >= 0.7
        in_discount = range_position <= 0.3
        in_equilibrium = range_position > 0.4 and range_position < 0.6

        [range_position * 100, in_premium, in_discount, in_equilibrium]

// ═══════════════════════════════════════════════════════════════════════════════════
// 💰 ENHANCED RISK MANAGEMENT CALCULATIONS
// ═══════════════════════════════════════════════════════════════════════════════════

export risk_management_enhanced(entry_price, stop_loss, take_profit, account_balance, risk_percentage) =>
    if na(entry_price) or na(stop_loss) or account_balance <= 0 or risk_percentage <= 0
        [na, na, na, na, na]
    else
        # Calculate risk metrics
        risk_distance = math.abs(entry_price - stop_loss)
        reward_distance = not na(take_profit) ? math.abs(take_profit - entry_price) : risk_distance * 2

        rr_ratio = reward_distance / risk_distance

        # Position sizing
        risk_amount = account_balance * (risk_percentage / 100)
        pip_value = syminfo.mintick * 10
        risk_pips = risk_distance / pip_value

        position_size = risk_pips > 0 ? risk_amount / (risk_pips * 10) : 0  # Simplified for major pairs
        position_size := math.min(position_size, account_balance * 0.1)  # Max 10% of account

        # Risk validation
        risk_valid = rr_ratio >= 1.5 and risk_pips >= 10 and risk_pips <= 100

        [risk_distance, reward_distance, rr_ratio, position_size, risk_valid]

export calculate_atr_stop_loss(entry_price, direction, atr_value, atr_multiplier) =>
    if na(entry_price) or na(atr_value) or atr_multiplier <= 0
        na
    else
        stop_distance = atr_value * atr_multiplier
        direction == 1 ? entry_price - stop_distance : entry_price + stop_distance

// ═══════════════════════════════════════════════════════════════════════════════════
// 🎯 ENHANCED CONFLUENCE SCORING SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════════

export calculate_confluence_score(bias_score, session_quality, volume_quality, structure_quality, fib_quality) =>
    total_score = 0.0
    max_possible = 50.0

    # Bias contribution (max 15 points)
    bias_contribution = math.abs(bias_score) >= 6 ? 15 : math.abs(bias_score) >= 4 ? 10 : math.abs(bias_score) >= 2 ? 7 : 3
    total_score += bias_contribution

    # Session quality (max 10 points)
    session_contribution = session_quality == "HIGH" ? 10 : session_quality == "MEDIUM" ? 7 : session_quality == "LOW" ? 4 : 2
    total_score += session_contribution

    # Volume quality (max 10 points)
    volume_contribution = volume_quality >= 2.0 ? 10 : volume_quality >= 1.5 ? 7 : volume_quality >= 1.2 ? 5 : 2
    total_score += volume_contribution

    # Structure quality (max 10 points)
    structure_contribution = structure_quality == "TRENDING" ? 8 : structure_quality == "RANGING" ? 6 : 4
    total_score += structure_contribution

    # Fibonacci/OTE quality (max 5 points)
    fib_contribution = fib_quality ? 5 : 2
    total_score += fib_contribution

    confluence_percentage = (total_score / max_possible) * 100
    confluence_rating = confluence_percentage >= 80 ? "EXCELLENT" :
                       confluence_percentage >= 65 ? "GOOD" :
                       confluence_percentage >= 50 ? "FAIR" : "POOR"

    [total_score, confluence_percentage, confluence_rating]

// ═══════════════════════════════════════════════════════════════════════════════════
// 📤 EXPORT SUMMARY FUNCTION
// ═══════════════════════════════════════════════════════════════════════════════════

export get_btmm_system_status() =>
    [asian, london, ny, overlap, session, cycle_day, cycle_phase, mm_activity] = session_and_cycle_enhanced()
    [htf, intermediate, execution, scalping, bias_tf, ote_tf, pattern_tf, tf_quality] = timeframe_classification_enhanced()

    system_health_score = 0
    if bias_tf
        system_health_score += 25
    if is_prime_trading_session()
        system_health_score += 25
    if tf_quality >= 7
        system_health_score += 25
    if mm_activity == "HIGH" or mm_activity == "MEDIUM"
        system_health_score += 25

    system_status = system_health_score >= 80 ? "OPTIMAL" :
                   system_health_score >= 60 ? "GOOD" :
                   system_health_score >= 40 ? "FAIR" : "SUBOPTIMAL"

    [session, cycle_day, cycle_phase, tf_quality, system_health_score, system_status]
